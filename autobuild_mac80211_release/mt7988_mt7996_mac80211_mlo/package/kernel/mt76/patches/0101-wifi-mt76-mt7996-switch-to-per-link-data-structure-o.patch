From 65da5e7d1c4ca9729c11bac4c289aef7b458ea4c Mon Sep 17 00:00:00 2001
From: Shayne Chen <shayne.chen@mediatek.com>
Date: Fri, 24 Nov 2023 11:31:55 +0800
Subject: [PATCH 101/120] wifi: mt76: mt7996: switch to per-link data structure
 of vif

Introduce struct mt7996_bss_conf, data structure for per-link BSS.
Note that mt7996_vif now represents a legacy or MLD device.
This is a preliminary patch to add MLO support for mt7996 chipsets.

Co-developed-by: Bo Jiao <Bo.Jiao@mediatek.com>
Signed-off-by: Bo Jiao <Bo.Jiao@mediatek.com>
Signed-off-by: Shayne Chen <shayne.chen@mediatek.com>
---
 mt7996/debugfs.c       |   10 +-
 mt7996/init.c          |    4 +-
 mt7996/mac.c           |   25 +-
 mt7996/main.c          |  269 ++++---
 mt7996/mcu.c           |  429 +++++------
 mt7996/mt7996.h        |   72 +-
 mt7996/mtk_debugfs_i.c | 1639 ++++++++++++++++++++++++++++++++++++++++
 mt7996/testmode.c      |   17 +-
 8 files changed, 2102 insertions(+), 363 deletions(-)
 create mode 100644 mt7996/mtk_debugfs_i.c

diff --git a/mt7996/debugfs.c b/mt7996/debugfs.c
index 36ee041c2..d4a74fef2 100644
--- a/mt7996/debugfs.c
+++ b/mt7996/debugfs.c
@@ -692,7 +692,7 @@ static void
 mt7996_sta_hw_queue_read(void *data, struct ieee80211_sta *sta)
 {
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
-	struct mt7996_dev *dev = msta->vif->phy->dev;
+	struct mt7996_dev *dev = msta->vif->deflink.phy->dev;
 	struct seq_file *s = data;
 	u8 ac;
 
@@ -712,7 +712,7 @@ mt7996_sta_hw_queue_read(void *data, struct ieee80211_sta *sta)
 				      GENMASK(11, 0));
 		seq_printf(s, "\tSTA %pM wcid %d: AC%d%d queued:%d\n",
 			   sta->addr, msta->wcid.idx,
-			   msta->vif->mt76.wmm_idx, ac, qlen);
+			   msta->vif->deflink.mt76.wmm_idx, ac, qlen);
 	}
 }
 
@@ -976,7 +976,7 @@ mt7996_atf_enable_set(void *data, u64 val)
 	int ret;
 
 	vow->max_deficit = val ? 64 : 1;
-	ret = mt7996_mcu_set_vow_drr_ctrl(phy, NULL, VOW_DRR_CTRL_AIRTIME_DEFICIT_BOUND);
+	ret = mt7996_mcu_set_vow_drr_ctrl(phy, NULL, NULL, VOW_DRR_CTRL_AIRTIME_DEFICIT_BOUND);
 	if (ret)
 		return ret;
 
@@ -1008,7 +1008,7 @@ mt7996_airtime_read(struct seq_file *s, void *data)
 
 		msta = container_of(wcid, struct mt7996_sta, wcid);
 		sta = container_of((void *)msta, struct ieee80211_sta, drv_priv);
-		vif = &msta->vif->mt76;
+		vif = &msta->vif->deflink.mt76;
 		stats = &wcid->stats;
 
 		seq_printf(s, "%pM WCID: %hu BandIdx: %hhu OmacIdx: 0x%hhx\t"
@@ -1152,7 +1152,7 @@ static ssize_t mt7996_sta_fixed_rate_set(struct file *file,
 #define LONG_PREAMBLE 1
 	struct ieee80211_sta *sta = file->private_data;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
-	struct mt7996_dev *dev = msta->vif->phy->dev;
+	struct mt7996_dev *dev = msta->vif->deflink.phy->dev;
 	struct ra_rate phy = {};
 	char buf[100];
 	int ret;
diff --git a/mt7996/init.c b/mt7996/init.c
index f91bdd0f0..541361b86 100644
--- a/mt7996/init.c
+++ b/mt7996/init.c
@@ -620,11 +620,11 @@ static int mt7996_vow_init(struct mt7996_phy *phy)
 	vow->drr_quantum[6] = VOW_DRR_QUANTUM_L6;
 	vow->drr_quantum[7] = VOW_DRR_QUANTUM_L7;
 
-	ret = mt7996_mcu_set_vow_drr_ctrl(phy, NULL, VOW_DRR_CTRL_AIRTIME_DEFICIT_BOUND);
+	ret = mt7996_mcu_set_vow_drr_ctrl(phy, NULL, NULL, VOW_DRR_CTRL_AIRTIME_DEFICIT_BOUND);
 	if (ret)
 		return ret;
 
-	ret = mt7996_mcu_set_vow_drr_ctrl(phy, NULL, VOW_DRR_CTRL_AIRTIME_QUANTUM_ALL);
+	ret = mt7996_mcu_set_vow_drr_ctrl(phy, NULL, NULL, VOW_DRR_CTRL_AIRTIME_QUANTUM_ALL);
 	if (ret)
 		return ret;
 
diff --git a/mt7996/mac.c b/mt7996/mac.c
index dc16be88a..3f36938fe 100644
--- a/mt7996/mac.c
+++ b/mt7996/mac.c
@@ -897,8 +897,9 @@ int mt7996_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
 
 	if (vif) {
 		struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+		struct mt7996_bss_conf *mconf = &mvif->deflink;
 
-		txp->fw.bss_idx = mvif->mt76.idx;
+		txp->fw.bss_idx = mconf->mt76.idx;
 	}
 
 	txp->fw.token = cpu_to_le16(id);
@@ -1518,12 +1519,15 @@ static void
 mt7996_update_vif_beacon(void *priv, u8 *mac, struct ieee80211_vif *vif)
 {
 	struct ieee80211_hw *hw = priv;
+	struct ieee80211_bss_conf *conf = &vif->bss_conf;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf = &mvif->deflink;
 
 	switch (vif->type) {
 	case NL80211_IFTYPE_MESH_POINT:
 	case NL80211_IFTYPE_ADHOC:
 	case NL80211_IFTYPE_AP:
-		mt7996_mcu_add_beacon(hw, vif, vif->bss_conf.enable_beacon);
+		mt7996_mcu_add_beacon(hw, conf, mconf, conf->enable_beacon);
 		break;
 	default:
 		break;
@@ -2237,6 +2241,8 @@ void mt7996_mac_sta_rc_work(struct work_struct *work)
 	struct mt7996_dev *dev = container_of(work, struct mt7996_dev, rc_work);
 	struct ieee80211_sta *sta;
 	struct ieee80211_vif *vif;
+	struct ieee80211_bss_conf *conf;
+	struct mt7996_bss_conf *mconf;
 	struct mt7996_sta *msta;
 	u32 changed;
 	LIST_HEAD(list);
@@ -2253,14 +2259,16 @@ void mt7996_mac_sta_rc_work(struct work_struct *work)
 
 		sta = container_of((void *)msta, struct ieee80211_sta, drv_priv);
 		vif = container_of((void *)msta->vif, struct ieee80211_vif, drv_priv);
+		conf = &vif->bss_conf;
+		mconf = &msta->vif->deflink;
 
 		if (changed & (IEEE80211_RC_SUPP_RATES_CHANGED |
 			       IEEE80211_RC_NSS_CHANGED |
 			       IEEE80211_RC_BW_CHANGED))
-			mt7996_mcu_add_rate_ctrl(dev, vif, sta, true);
+			mt7996_mcu_add_rate_ctrl(dev, conf, mconf, sta, true);
 
 		if (changed & IEEE80211_RC_SMPS_CHANGED)
-			mt7996_mcu_set_fixed_field(dev, vif, sta, NULL,
+			mt7996_mcu_set_fixed_field(dev, mconf, sta, NULL,
 						   RATE_PARAM_MMPS_UPDATE);
 
 		spin_lock_bh(&dev->mt76.sta_poll_lock);
@@ -2639,7 +2647,7 @@ void mt7996_mac_add_twt_setup(struct ieee80211_hw *hw,
 
 		flow->sched = true;
 		flow->start_tsf = mt7996_mac_twt_sched_list_add(dev, flow);
-		curr_tsf = __mt7996_get_tsf(hw, msta->vif);
+		curr_tsf = __mt7996_get_tsf(hw, &msta->vif->deflink);
 		div_u64_rem(curr_tsf - flow->start_tsf, interval, &rem);
 		flow_tsf = curr_tsf + interval - rem;
 		twt_agrt->twt = cpu_to_le64(flow_tsf);
@@ -2648,7 +2656,8 @@ void mt7996_mac_add_twt_setup(struct ieee80211_hw *hw,
 	}
 	flow->tsf = le64_to_cpu(twt_agrt->twt);
 
-	if (mt7996_mcu_twt_agrt_update(dev, msta->vif, flow, MCU_TWT_AGRT_ADD))
+	if (mt7996_mcu_twt_agrt_update(dev, &msta->vif->deflink, flow,
+				       MCU_TWT_AGRT_ADD))
 		goto unlock;
 
 	setup_cmd = TWT_SETUP_CMD_ACCEPT;
@@ -2670,6 +2679,7 @@ void mt7996_mac_twt_teardown_flow(struct mt7996_dev *dev,
 				  u8 flowid)
 {
 	struct mt7996_twt_flow *flow;
+	struct mt7996_bss_conf *mconf = mconf_dereference_protected(msta->vif, 0);
 
 	lockdep_assert_held(&dev->mt76.mutex);
 
@@ -2680,8 +2690,7 @@ void mt7996_mac_twt_teardown_flow(struct mt7996_dev *dev,
 		return;
 
 	flow = &msta->twt.flow[flowid];
-	if (mt7996_mcu_twt_agrt_update(dev, msta->vif, flow,
-				       MCU_TWT_AGRT_DELETE))
+	if (mt7996_mcu_twt_agrt_update(dev, mconf, flow, MCU_TWT_AGRT_DELETE))
 		return;
 
 	list_del_init(&flow->list);
diff --git a/mt7996/main.c b/mt7996/main.c
index 66376e27c..7ea81e94c 100644
--- a/mt7996/main.c
+++ b/mt7996/main.c
@@ -204,29 +204,30 @@ static int get_omac_idx(enum nl80211_iftype type, u64 mask)
 	return -1;
 }
 
-static void mt7996_init_bitrate_mask(struct ieee80211_vif *vif)
+static void mt7996_init_bitrate_mask(struct mt7996_bss_conf *mconf)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(mvif->bitrate_mask.control); i++) {
-		mvif->bitrate_mask.control[i].gi = NL80211_TXRATE_DEFAULT_GI;
-		mvif->bitrate_mask.control[i].he_gi = 0xff;
-		mvif->bitrate_mask.control[i].he_ltf = 0xff;
-		mvif->bitrate_mask.control[i].legacy = GENMASK(31, 0);
-		memset(mvif->bitrate_mask.control[i].ht_mcs, 0xff,
-		       sizeof(mvif->bitrate_mask.control[i].ht_mcs));
-		memset(mvif->bitrate_mask.control[i].vht_mcs, 0xff,
-		       sizeof(mvif->bitrate_mask.control[i].vht_mcs));
-		memset(mvif->bitrate_mask.control[i].he_mcs, 0xff,
-		       sizeof(mvif->bitrate_mask.control[i].he_mcs));
+	for (i = 0; i < ARRAY_SIZE(mconf->bitrate_mask.control); i++) {
+		mconf->bitrate_mask.control[i].gi = NL80211_TXRATE_DEFAULT_GI;
+		mconf->bitrate_mask.control[i].he_gi = 0xff;
+		mconf->bitrate_mask.control[i].he_ltf = 0xff;
+		mconf->bitrate_mask.control[i].legacy = GENMASK(31, 0);
+		memset(mconf->bitrate_mask.control[i].ht_mcs, 0xff,
+		       sizeof(mconf->bitrate_mask.control[i].ht_mcs));
+		memset(mconf->bitrate_mask.control[i].vht_mcs, 0xff,
+		       sizeof(mconf->bitrate_mask.control[i].vht_mcs));
+		memset(mconf->bitrate_mask.control[i].he_mcs, 0xff,
+		       sizeof(mconf->bitrate_mask.control[i].he_mcs));
 	}
 }
 
 static int mt7996_add_interface(struct ieee80211_hw *hw,
 				struct ieee80211_vif *vif)
 {
+	struct ieee80211_bss_conf *conf = &vif->bss_conf;
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf = &mvif->deflink;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_phy *phy = mt7996_hw_phy(hw);
 	struct mt76_txq *mtxq;
@@ -239,8 +240,8 @@ static int mt7996_add_interface(struct ieee80211_hw *hw,
 	    is_zero_ether_addr(vif->addr))
 		phy->monitor_vif = vif;
 
-	mvif->mt76.idx = __ffs64(~dev->mt76.vif_mask);
-	if (mvif->mt76.idx >= mt7996_max_interface_num(dev)) {
+	mconf->mt76.idx = __ffs64(~dev->mt76.vif_mask);
+	if (mconf->mt76.idx >= mt7996_max_interface_num(dev)) {
 		ret = -ENOSPC;
 		goto out;
 	}
@@ -250,19 +251,21 @@ static int mt7996_add_interface(struct ieee80211_hw *hw,
 		ret = -ENOSPC;
 		goto out;
 	}
-	mvif->mt76.omac_idx = idx;
-	mvif->phy = phy;
-	mvif->mt76.band_idx = band_idx;
-	mvif->mt76.wmm_idx = vif->type != NL80211_IFTYPE_AP;
-
-	ret = mt7996_mcu_add_dev_info(phy, vif, true);
+	mconf->mt76.omac_idx = idx;
+	mconf->vif = mvif;
+	mconf->phy = phy;
+	mconf->mt76.band_idx = band_idx;
+	mconf->mt76.wmm_idx = vif->type != NL80211_IFTYPE_AP;
+	mvif->dev = dev;
+
+	ret = mt7996_mcu_add_dev_info(phy, conf, mconf, true);
 	if (ret)
 		goto out;
 
-	dev->mt76.vif_mask |= BIT_ULL(mvif->mt76.idx);
-	phy->omac_mask |= BIT_ULL(mvif->mt76.omac_idx);
+	dev->mt76.vif_mask |= BIT_ULL(mconf->mt76.idx);
+	phy->omac_mask |= BIT_ULL(mconf->mt76.omac_idx);
 
-	idx = MT7996_WTBL_RESERVED - mvif->mt76.idx;
+	idx = MT7996_WTBL_RESERVED - mconf->mt76.idx;
 
 	INIT_LIST_HEAD(&mvif->sta.rc_list);
 	INIT_LIST_HEAD(&mvif->sta.wcid.poll_list);
@@ -282,24 +285,25 @@ static int mt7996_add_interface(struct ieee80211_hw *hw,
 	}
 
 	if (vif->type != NL80211_IFTYPE_AP &&
-	    (!mvif->mt76.omac_idx || mvif->mt76.omac_idx > 3))
+	    (!mconf->mt76.omac_idx || mconf->mt76.omac_idx > 3))
 		vif->offload_flags = 0;
 	vif->offload_flags |= IEEE80211_OFFLOAD_ENCAP_4ADDR;
 
 	if (phy->mt76->chandef.chan->band != NL80211_BAND_2GHZ)
-		mvif->mt76.basic_rates_idx = MT7996_BASIC_RATES_TBL + 4;
+		mconf->mt76.basic_rates_idx = MT7996_BASIC_RATES_TBL + 4;
 	else
-		mvif->mt76.basic_rates_idx = MT7996_BASIC_RATES_TBL;
+		mconf->mt76.basic_rates_idx = MT7996_BASIC_RATES_TBL;
 
-	mt7996_init_bitrate_mask(vif);
+	mt7996_init_bitrate_mask(mconf);
 
-	mt7996_mcu_add_bss_info(phy, vif, true);
+	mt7996_mcu_add_bss_info(phy, conf, mconf, true);
 	/* defer the first STA_REC of BMC entry to BSS_CHANGED_BSSID for STA
 	 * interface, since firmware only records BSSID when the entry is new
 	 */
 	if (vif->type != NL80211_IFTYPE_STATION)
-		mt7996_mcu_add_sta(dev, vif, NULL, true, true);
+		mt7996_mcu_add_sta(dev, conf, mconf, NULL, true, true);
 	rcu_assign_pointer(dev->mt76.wcid[idx], &mvif->sta.wcid);
+	rcu_assign_pointer(mvif->link[0], mconf);
 
 out:
 	mutex_unlock(&dev->mt76.mutex);
@@ -310,7 +314,9 @@ out:
 static void mt7996_remove_interface(struct ieee80211_hw *hw,
 				    struct ieee80211_vif *vif)
 {
+	struct ieee80211_bss_conf *conf;
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf;
 	struct mt7996_sta *msta = &mvif->sta;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_phy *phy = mt7996_hw_phy(hw);
@@ -318,24 +324,22 @@ static void mt7996_remove_interface(struct ieee80211_hw *hw,
 
 	cancel_delayed_work_sync(&phy->scan_work);
 
-	mt7996_mcu_add_sta(dev, vif, NULL, false, false);
-	mt7996_mcu_add_bss_info(phy, vif, false);
+	mutex_lock(&dev->mt76.mutex);
+
+	conf = link_conf_dereference_protected(vif, 0);
+	mconf = mconf_dereference_protected(mvif, 0);
+	mt7996_mcu_add_sta(dev, conf, mconf, NULL, false, false);
+	mt7996_mcu_add_bss_info(phy, conf, mconf, false);
 
 	if (vif == phy->monitor_vif)
 		phy->monitor_vif = NULL;
 
-	mt7996_mcu_add_dev_info(phy, vif, false);
+	mt7996_mcu_add_dev_info(phy, conf, mconf, false);
 
 	rcu_assign_pointer(dev->mt76.wcid[idx], NULL);
 
-	mutex_lock(&dev->mt76.mutex);
-
-	if (test_bit(MT76_SCANNING, &phy->mt76->state))
-		mt7996_scan_complete(phy, true);
-
-	dev->mt76.vif_mask &= ~BIT_ULL(mvif->mt76.idx);
-	phy->omac_mask &= ~BIT_ULL(mvif->mt76.omac_idx);
-	mutex_unlock(&dev->mt76.mutex);
+	dev->mt76.vif_mask &= ~BIT_ULL(mconf->mt76.idx);
+	phy->omac_mask &= ~BIT_ULL(mconf->mt76.omac_idx);
 
 	spin_lock_bh(&dev->mt76.sta_poll_lock);
 	if (!list_empty(&msta->wcid.poll_list))
@@ -343,6 +347,9 @@ static void mt7996_remove_interface(struct ieee80211_hw *hw,
 	spin_unlock_bh(&dev->mt76.sta_poll_lock);
 
 	mt76_wcid_cleanup(&dev->mt76, &msta->wcid);
+	rcu_assign_pointer(mvif->link[0], NULL);
+
+	mutex_unlock(&dev->mt76.mutex);
 }
 
 static void ___mt7996_set_channel(struct mt7996_phy *phy,
@@ -440,6 +447,8 @@ static int mt7996_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
 	struct mt7996_sta *msta = sta ? (struct mt7996_sta *)sta->drv_priv :
 				  &mvif->sta;
 	struct mt76_wcid *wcid = &msta->wcid;
+	struct mt7996_bss_conf *mconf;
+	struct ieee80211_bss_conf *conf;
 	u8 *wcid_keyidx = &wcid->hw_key_idx;
 	int idx = key->keyidx;
 	int err = 0;
@@ -480,9 +489,11 @@ static int mt7996_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
 
 	mutex_lock(&dev->mt76.mutex);
 
-	if (cmd == SET_KEY && !sta && !mvif->mt76.cipher) {
-		mvif->mt76.cipher = mt76_connac_mcu_get_cipher(key->cipher);
-		mt7996_mcu_add_bss_info(phy, vif, true);
+	conf = link_conf_dereference_protected(vif, 0);
+	mconf = mconf_dereference_protected(mvif, 0);
+	if (cmd == SET_KEY && !sta && !mconf->mt76.cipher) {
+		mconf->mt76.cipher = mt76_connac_mcu_get_cipher(key->cipher);
+		mt7996_mcu_add_bss_info(phy, conf, mconf, true);
 	}
 
 	if (cmd == SET_KEY) {
@@ -496,9 +507,9 @@ static int mt7996_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
 	mt76_wcid_key_setup(&dev->mt76, wcid, key);
 
 	if (key->keyidx == 6 || key->keyidx == 7)
-		err = mt7996_mcu_bcn_prot_enable(dev, vif, key);
+		err = mt7996_mcu_bcn_prot_enable(dev, conf, mconf, key);
 	else
-		err = mt7996_mcu_add_key(&dev->mt76, vif, key,
+		err = mt7996_mcu_add_key(&dev->mt76, mconf, key,
 					 MCU_WMWA_UNI_CMD(STA_REC_UPDATE),
 					 &msta->wcid, cmd);
 out:
@@ -545,7 +556,9 @@ mt7996_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	       unsigned int link_id, u16 queue,
 	       const struct ieee80211_tx_queue_params *params)
 {
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf;
 	const u8 mq_to_aci[] = {
 		[IEEE80211_AC_VO] = 3,
 		[IEEE80211_AC_VI] = 2,
@@ -553,10 +566,15 @@ mt7996_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		[IEEE80211_AC_BK] = 1,
 	};
 
+	mutex_lock(&dev->mt76.mutex);
+	mconf = mconf_dereference_protected(mvif, 0);
+
 	/* firmware uses access class index */
-	mvif->queue_params[mq_to_aci[queue]] = *params;
+	mconf->queue_params[mq_to_aci[queue]] = *params;
 	/* no need to update right away, we'll get BSS_CHANGED_QOS */
 
+	mutex_unlock(&dev->mt76.mutex);
+
 	return 0;
 }
 
@@ -617,22 +635,20 @@ static void mt7996_configure_filter(struct ieee80211_hw *hw,
 }
 
 static void
-mt7996_update_bss_color(struct ieee80211_hw *hw,
-			struct ieee80211_vif *vif,
+mt7996_update_bss_color(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			struct mt7996_bss_conf *mconf,
 			struct cfg80211_he_bss_color *bss_color)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 
 	switch (vif->type) {
 	case NL80211_IFTYPE_AP: {
-		struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-
-		if (mvif->mt76.omac_idx > HW_BSSID_MAX)
+		if (mconf->mt76.omac_idx > HW_BSSID_MAX)
 			return;
 		fallthrough;
 	}
 	case NL80211_IFTYPE_STATION:
-		mt7996_mcu_update_bss_color(dev, vif, bss_color);
+		mt7996_mcu_update_bss_color(dev, mconf, bss_color);
 		break;
 	default:
 		break;
@@ -640,16 +656,15 @@ mt7996_update_bss_color(struct ieee80211_hw *hw,
 }
 
 static u8
-mt7996_get_rates_table(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-		       bool beacon, bool mcast)
+mt7996_get_rates_table(struct ieee80211_hw *hw, struct ieee80211_bss_conf *conf,
+		       struct mt7996_bss_conf *mconf, bool beacon, bool mcast)
 {
-	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt76_phy *mphy = hw->priv;
+	struct mt76_phy *mphy = mconf->phy->mt76;
 	u16 rate;
 	u8 i, idx;
 
-	rate = mt76_connac2_mac_tx_rate_val(mphy, vif, beacon, mcast);
+	rate = mt76_connac2_mac_tx_rate_val(mphy, conf->vif, beacon, mcast);
 
 	if (beacon) {
 		struct mt7996_phy *phy = mphy->priv;
@@ -670,23 +685,22 @@ mt7996_get_rates_table(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		if ((mt76_rates[i].hw_value & GENMASK(7, 0)) == idx)
 			return MT7996_BASIC_RATES_TBL + 2 * i;
 
-	return mvif->basic_rates_idx;
+	return mconf->mt76.basic_rates_idx;
 }
 
 static void
-mt7996_update_mu_group(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-		       struct ieee80211_bss_conf *info)
+mt7996_update_mu_group(struct ieee80211_hw *hw, struct ieee80211_bss_conf *conf,
+		       struct mt7996_bss_conf *mconf)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	u8 band = mvif->mt76.band_idx;
+	u8 band = mconf->mt76.band_idx;
 	u32 *mu;
 
-	mu = (u32 *)info->mu_group.membership;
+	mu = (u32 *)conf->mu_group.membership;
 	mt76_wr(dev, MT_WF_PHYRX_BAND_GID_TAB_VLD0(band), mu[0]);
 	mt76_wr(dev, MT_WF_PHYRX_BAND_GID_TAB_VLD1(band), mu[1]);
 
-	mu = (u32 *)info->mu_group.position;
+	mu = (u32 *)conf->mu_group.position;
 	mt76_wr(dev, MT_WF_PHYRX_BAND_GID_TAB_POS0(band), mu[0]);
 	mt76_wr(dev, MT_WF_PHYRX_BAND_GID_TAB_POS1(band), mu[1]);
 	mt76_wr(dev, MT_WF_PHYRX_BAND_GID_TAB_POS2(band), mu[2]);
@@ -698,20 +712,22 @@ static void mt7996_bss_info_changed(struct ieee80211_hw *hw,
 				    struct ieee80211_bss_conf *info,
 				    u64 changed)
 {
-	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf;
 	struct mt7996_phy *phy = mt7996_hw_phy(hw);
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 
 	mutex_lock(&dev->mt76.mutex);
 
+	mconf = mconf_dereference_protected(mvif, 0);
 	/* station mode uses BSSID to map the wlan entry to a peer,
 	 * and then peer references bss_info_rfch to set bandwidth cap.
 	 */
 	if ((changed & BSS_CHANGED_BSSID && !is_zero_ether_addr(info->bssid)) ||
 	    (changed & BSS_CHANGED_ASSOC && vif->cfg.assoc) ||
 	    (changed & BSS_CHANGED_BEACON_ENABLED && info->enable_beacon)) {
-		mt7996_mcu_add_bss_info(phy, vif, true);
-		mt7996_mcu_add_sta(dev, vif, NULL, true,
+		mt7996_mcu_add_bss_info(phy, info, mconf, true);
+		mt7996_mcu_add_sta(dev, info, mconf, NULL, true,
 				   !!(changed & BSS_CHANGED_BSSID));
 	}
 
@@ -723,42 +739,42 @@ static void mt7996_bss_info_changed(struct ieee80211_hw *hw,
 
 		if (slottime != phy->slottime) {
 			phy->slottime = slottime;
-			mt7996_mcu_set_timing(phy, vif);
+			mt7996_mcu_set_timing(phy, mconf);
 		}
 	}
 
 	if (changed & BSS_CHANGED_MCAST_RATE)
-		mvif->mcast_rates_idx =
-			mt7996_get_rates_table(hw, vif, false, true);
+		mconf->mt76.mcast_rates_idx =
+			mt7996_get_rates_table(hw, info, mconf, false, true);
 
 	if (changed & BSS_CHANGED_BASIC_RATES)
-		mvif->basic_rates_idx =
-			mt7996_get_rates_table(hw, vif, false, false);
+		mconf->mt76.basic_rates_idx =
+			mt7996_get_rates_table(hw, info, mconf, false, false);
 
 	/* ensure that enable txcmd_mode after bss_info */
 	if (changed & (BSS_CHANGED_QOS | BSS_CHANGED_BEACON_ENABLED))
-		mt7996_mcu_set_tx(dev, vif);
+		mt7996_mcu_set_tx(dev, mconf);
 
 	if (changed & BSS_CHANGED_HE_OBSS_PD)
-		mt7996_mcu_add_obss_spr(phy, vif, &info->he_obss_pd);
+		mt7996_mcu_add_obss_spr(phy, mconf, &info->he_obss_pd);
 
 	if (changed & BSS_CHANGED_HE_BSS_COLOR)
-		mt7996_update_bss_color(hw, vif, &info->he_bss_color);
+		mt7996_update_bss_color(hw, vif, mconf, &info->he_bss_color);
 
 	if (changed & (BSS_CHANGED_BEACON |
 		       BSS_CHANGED_BEACON_ENABLED)) {
-		mvif->beacon_rates_idx =
-			mt7996_get_rates_table(hw, vif, true, false);
+		mconf->mt76.beacon_rates_idx =
+			mt7996_get_rates_table(hw, info, mconf, true, false);
 
-		mt7996_mcu_add_beacon(hw, vif, info->enable_beacon);
+		mt7996_mcu_add_beacon(hw, info, mconf, info->enable_beacon);
 	}
 
 	if (changed & (BSS_CHANGED_UNSOL_BCAST_PROBE_RESP |
 		       BSS_CHANGED_FILS_DISCOVERY))
-		mt7996_mcu_beacon_inband_discov(dev, vif, changed);
+		mt7996_mcu_beacon_inband_discov(dev, info, mconf, changed);
 
 	if (changed & BSS_CHANGED_MU_GROUPS)
-		mt7996_update_mu_group(hw, vif, info);
+		mt7996_update_mu_group(hw, info, mconf);
 
 	mutex_unlock(&dev->mt76.mutex);
 }
@@ -769,9 +785,14 @@ mt7996_channel_switch_beacon(struct ieee80211_hw *hw,
 			     struct cfg80211_chan_def *chandef)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf;
+	struct ieee80211_bss_conf *conf;
 
 	mutex_lock(&dev->mt76.mutex);
-	mt7996_mcu_add_beacon(hw, vif, true);
+	mconf = mconf_dereference_protected(mvif, 0);
+	conf = link_conf_dereference_protected(vif, 0);
+	mt7996_mcu_add_beacon(hw, conf, mconf, true);
 	mutex_unlock(&dev->mt76.mutex);
 }
 
@@ -781,7 +802,8 @@ int mt7996_mac_sta_add(struct mt76_dev *mdev, struct ieee80211_vif *vif,
 	struct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	u8 band_idx = mvif->phy->mt76->band_idx;
+	struct mt7996_bss_conf *mconf = mconf_dereference_protected(mvif, 0);
+	u8 band_idx = mconf->phy->mt76->band_idx;
 	int idx;
 
 #ifdef CONFIG_MTK_VENDOR
@@ -801,7 +823,7 @@ int mt7996_mac_sta_add(struct mt76_dev *mdev, struct ieee80211_vif *vif,
 	msta->wcid.tx_info |= MT_WCID_TX_INFO_SET;
 
 #ifdef CONFIG_MTK_VENDOR
-	mt7996_vendor_amnt_sta_remove(mvif->phy, sta);
+	mt7996_vendor_amnt_sta_remove(mconf->phy, sta);
 #endif
 
 #ifdef CONFIG_MTK_VENDOR
@@ -828,15 +850,20 @@ void mt7996_mac_sta_assoc(struct mt76_dev *mdev, struct ieee80211_vif *vif,
 			  struct ieee80211_sta *sta)
 {
 	struct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_bss_conf *mconf;
+	struct ieee80211_bss_conf *conf;
 
 	mutex_lock(&dev->mt76.mutex);
 
 	mt7996_mac_wtbl_update(dev, msta->wcid.idx,
 			       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
 
-	mt7996_mcu_add_sta(dev, vif, sta, true, true);
-	mt7996_mcu_add_rate_ctrl(dev, vif, sta, false);
+	conf = link_conf_dereference_protected(vif, 0);
+	mconf = mconf_dereference_protected(mvif, 0);
+	mt7996_mcu_add_sta(dev, conf, mconf, sta, true, true);
+	mt7996_mcu_add_rate_ctrl(dev, conf, mconf, sta, false);
 
 	ewma_avg_signal_init(&msta->avg_ack_signal);
 
@@ -847,10 +874,15 @@ void mt7996_mac_sta_remove(struct mt76_dev *mdev, struct ieee80211_vif *vif,
 			   struct ieee80211_sta *sta)
 {
 	struct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_bss_conf *mconf;
+	struct ieee80211_bss_conf *conf;
 	int i;
 
-	mt7996_mcu_add_sta(dev, vif, sta, false, false);
+	conf = link_conf_dereference_protected(vif, 0);
+	mconf = mconf_dereference_protected(mvif, 0);
+	mt7996_mcu_add_sta(dev, conf, mconf, sta, false, false);
 
 	mt7996_mac_wtbl_update(dev, msta->wcid.idx,
 			       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
@@ -982,7 +1014,7 @@ mt7996_get_stats(struct ieee80211_hw *hw,
 	return 0;
 }
 
-u64 __mt7996_get_tsf(struct ieee80211_hw *hw, struct mt7996_vif *mvif)
+u64 __mt7996_get_tsf(struct ieee80211_hw *hw, struct mt7996_bss_conf *mconf)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_phy *phy = mt7996_hw_phy(hw);
@@ -994,8 +1026,8 @@ u64 __mt7996_get_tsf(struct ieee80211_hw *hw, struct mt7996_vif *mvif)
 
 	lockdep_assert_held(&dev->mt76.mutex);
 
-	n = mvif->mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0
-					       : mvif->mt76.omac_idx;
+	n = mconf->mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0
+					       : mconf->mt76.omac_idx;
 	/* TSF software read */
 	mt76_rmw(dev, MT_LPON_TCR(phy->mt76->band_idx, n), MT_LPON_TCR_SW_MODE,
 		 MT_LPON_TCR_SW_READ);
@@ -1010,10 +1042,12 @@ mt7996_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_bss_conf *mconf;
 	u64 ret;
 
 	mutex_lock(&dev->mt76.mutex);
-	ret = __mt7996_get_tsf(hw, mvif);
+	mconf = mconf_dereference_protected(mvif, 0);
+	ret = __mt7996_get_tsf(hw, mconf);
 	mutex_unlock(&dev->mt76.mutex);
 
 	return ret;
@@ -1026,6 +1060,7 @@ mt7996_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct mt7996_bss_conf *mconf;
 	union {
 		u64 t64;
 		u32 t32[2];
@@ -1034,8 +1069,9 @@ mt7996_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 
 	mutex_lock(&dev->mt76.mutex);
 
-	n = mvif->mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0
-					       : mvif->mt76.omac_idx;
+	mconf = mconf_dereference_protected(mvif, 0);
+	n = mconf->mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0
+					       : mconf->mt76.omac_idx;
 	mt76_wr(dev, MT_LPON_UTTR0(phy->mt76->band_idx), tsf.t32[0]);
 	mt76_wr(dev, MT_LPON_UTTR1(phy->mt76->band_idx), tsf.t32[1]);
 	/* TSF software overwrite */
@@ -1052,6 +1088,7 @@ mt7996_offset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct mt7996_bss_conf *mconf;
 	union {
 		u64 t64;
 		u32 t32[2];
@@ -1060,8 +1097,9 @@ mt7996_offset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 
 	mutex_lock(&dev->mt76.mutex);
 
-	n = mvif->mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0
-					       : mvif->mt76.omac_idx;
+	mconf = mconf_dereference_protected(mvif, 0);
+	n = mconf->mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0
+					       : mconf->mt76.omac_idx;
 	mt76_wr(dev, MT_LPON_UTTR0(phy->mt76->band_idx), tsf.t32[0]);
 	mt76_wr(dev, MT_LPON_UTTR1(phy->mt76->band_idx), tsf.t32[1]);
 	/* TSF software adjust*/
@@ -1177,7 +1215,7 @@ static void mt7996_sta_statistics(struct ieee80211_hw *hw,
 static void mt7996_sta_rc_work(void *data, struct ieee80211_sta *sta)
 {
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
-	struct mt7996_dev *dev = msta->vif->phy->dev;
+	struct mt7996_dev *dev = msta->vif->dev;
 	u32 *changed = data;
 
 	spin_lock_bh(&dev->mt76.sta_poll_lock);
@@ -1213,9 +1251,13 @@ mt7996_set_bitrate_mask(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_phy *phy = mt7996_hw_phy(hw);
 	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_bss_conf *mconf;
 	u32 changed = IEEE80211_RC_SUPP_RATES_CHANGED;
 
-	mvif->bitrate_mask = *mask;
+	mutex_lock(&dev->mt76.mutex);
+	mconf = mconf_dereference_protected(mvif, 0);
+	mconf->bitrate_mask = *mask;
+	mutex_unlock(&dev->mt76.mutex);
 
 	/* if multiple rates across different preambles are given we can
 	 * reconfigure this info with all peers using sta_rec command with
@@ -1237,14 +1279,20 @@ static void mt7996_sta_set_4addr(struct ieee80211_hw *hw,
 				 bool enabled)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_bss_conf *mconf;
+
+	mutex_lock(&dev->mt76.mutex);
+	mconf = mconf_dereference_protected(mvif, 0);
 
 	if (enabled)
 		set_bit(MT_WCID_FLAG_4ADDR, &msta->wcid.flags);
 	else
 		clear_bit(MT_WCID_FLAG_4ADDR, &msta->wcid.flags);
 
-	mt7996_mcu_wtbl_update_hdr_trans(dev, vif, sta);
+	mt7996_mcu_wtbl_update_hdr_trans(dev, vif, mconf, sta);
+	mutex_unlock(&dev->mt76.mutex);
 }
 
 static void mt7996_sta_set_decap_offload(struct ieee80211_hw *hw,
@@ -1253,14 +1301,20 @@ static void mt7996_sta_set_decap_offload(struct ieee80211_hw *hw,
 					 bool enabled)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_bss_conf *mconf;
+
+	mutex_lock(&dev->mt76.mutex);
+	mconf = mconf_dereference_protected(mvif, 0);
 
 	if (enabled)
 		set_bit(MT_WCID_FLAG_HDR_TRANS, &msta->wcid.flags);
 	else
 		clear_bit(MT_WCID_FLAG_HDR_TRANS, &msta->wcid.flags);
 
-	mt7996_mcu_wtbl_update_hdr_trans(dev, vif, sta);
+	mt7996_mcu_wtbl_update_hdr_trans(dev, vif, mconf, sta);
+	mutex_unlock(&dev->mt76.mutex);
 }
 
 static const char mt7996_gstrings_stats[][ETH_GSTRING_LEN] = {
@@ -1393,7 +1447,7 @@ static void mt7996_ethtool_worker(void *wi_data, struct ieee80211_sta *sta)
 	struct mt76_ethtool_worker_info *wi = wi_data;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
 
-	if (msta->vif->mt76.idx != wi->idx)
+	if (msta->vif->deflink.mt76.idx != wi->idx)
 		return;
 
 	mt76_ethtool_worker(wi, &msta->wcid.stats, true);
@@ -1407,15 +1461,17 @@ void mt7996_get_et_stats(struct ieee80211_hw *hw,
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_phy *phy = mt7996_hw_phy(hw);
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf;
 	struct mt76_mib_stats *mib = &phy->mib;
 	struct mt76_ethtool_worker_info wi = {
 		.data = data,
-		.idx = mvif->mt76.idx,
 	};
 	/* See mt7996_ampdu_stat_read_phy, etc */
 	int i, ei = 0;
 
 	mutex_lock(&dev->mt76.mutex);
+	mconf = mconf_dereference_protected(mvif, 0);
+	wi.idx = mconf->mt76.idx,
 
 	mt7996_mac_update_stats(phy);
 
@@ -1621,6 +1677,7 @@ mt7996_net_fill_forward_path(struct ieee80211_hw *hw,
 			     struct net_device_path *path)
 {
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf = &mvif->deflink;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_phy *phy = mt7996_hw_phy(hw);
@@ -1649,7 +1706,7 @@ mt7996_net_fill_forward_path(struct ieee80211_hw *hw,
 	path->type = DEV_PATH_MTK_WDMA;
 	path->dev = ctx->dev;
 	path->mtk_wdma.wdma_idx = wed->wdma_idx;
-	path->mtk_wdma.bss = mvif->mt76.idx;
+	path->mtk_wdma.bss = mconf->mt76.idx;
 	path->mtk_wdma.queue = 0;
 	path->mtk_wdma.wcid = msta->wcid.idx;
 
@@ -1777,6 +1834,7 @@ mt7996_assign_vif_chanctx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	struct mt7996_chanctx *ctx = mt7996_chanctx_get(conf);
 	struct mt7996_phy *phy = ctx->phy;
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf;
 
 	wiphy_info(hw->wiphy, "Assign VIF (addr: %pM, type: %d, link_id: %d) to channel context: %d MHz\n",
 		    vif->addr, vif->type, link_conf->link_id,
@@ -1784,7 +1842,8 @@ mt7996_assign_vif_chanctx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 
 	mutex_lock(&phy->dev->mt76.mutex);
 
-	mvif->chanctx = ctx;
+	mconf = mconf_dereference_protected(mvif, 0);
+	mconf->chanctx = ctx;
 	ctx->nbss_assigned++;
 
 	mutex_unlock(&phy->dev->mt76.mutex);
@@ -1800,6 +1859,7 @@ mt7996_unassign_vif_chanctx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	struct mt7996_chanctx *ctx = mt7996_chanctx_get(conf);
 	struct mt7996_phy *phy = ctx->phy;
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf;
 
 	wiphy_info(hw->wiphy, "Remove VIF (addr: %pM, type: %d, link_id: %d) from channel context: %d MHz\n",
 		   vif->addr, vif->type, link_conf->link_id,
@@ -1811,7 +1871,8 @@ mt7996_unassign_vif_chanctx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	if (test_bit(MT76_SCANNING, &phy->mt76->state))
 		mt7996_scan_complete(phy, true);
 
-	mvif->chanctx = NULL;
+	mconf = mconf_dereference_protected(mvif, 0);
+	mconf->chanctx = NULL;
 	ctx->nbss_assigned--;
 
 	mutex_unlock(&phy->dev->mt76.mutex);
diff --git a/mt7996/mcu.c b/mt7996/mcu.c
index 7e7c5ff95..2806aa0dd 100644
--- a/mt7996/mcu.c
+++ b/mt7996/mcu.c
@@ -117,12 +117,12 @@ mt7996_mcu_get_sta_nss(u16 mcs_map)
 }
 
 static void
-mt7996_mcu_set_sta_he_mcs(struct ieee80211_sta *sta, __le16 *he_mcs,
-			  u16 mcs_map)
+mt7996_mcu_set_sta_he_mcs(struct ieee80211_sta *sta,
+			  struct mt7996_bss_conf *mconf,
+			  __le16 *he_mcs, u16 mcs_map)
 {
-	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
-	enum nl80211_band band = msta->vif->phy->mt76->chandef.chan->band;
-	const u16 *mask = msta->vif->bitrate_mask.control[band].he_mcs;
+	enum nl80211_band band = mconf->phy->mt76->chandef.chan->band;
+	const u16 *mask = mconf->bitrate_mask.control[band].he_mcs;
 	int nss, max_nss = sta->deflink.rx_nss > 3 ? 4 : sta->deflink.rx_nss;
 
 	for (nss = 0; nss < max_nss; nss++) {
@@ -920,8 +920,7 @@ mt7996_mcu_add_uni_tlv(struct sk_buff *skb, u16 tag, u16 len)
 }
 
 static void
-mt7996_mcu_bss_rfch_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
-			struct mt7996_phy *phy)
+mt7996_mcu_bss_rfch_tlv(struct sk_buff *skb, struct mt7996_phy *phy)
 {
 	static const u8 rlm_ch_band[] = {
 		[NL80211_BAND_2GHZ] = 1,
@@ -951,8 +950,7 @@ mt7996_mcu_bss_rfch_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
 }
 
 static void
-mt7996_mcu_bss_ra_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
-		      struct mt7996_phy *phy)
+mt7996_mcu_bss_ra_tlv(struct sk_buff *skb)
 {
 	struct bss_ra_tlv *ra;
 	struct tlv *tlv;
@@ -964,7 +962,7 @@ mt7996_mcu_bss_ra_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
 }
 
 static void
-mt7996_mcu_bss_he_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
+mt7996_mcu_bss_he_tlv(struct sk_buff *skb, struct ieee80211_bss_conf *conf,
 		      struct mt7996_phy *phy)
 {
 #define DEFAULT_HE_PE_DURATION		4
@@ -973,16 +971,16 @@ mt7996_mcu_bss_he_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
 	struct bss_info_uni_he *he;
 	struct tlv *tlv;
 
-	cap = mt76_connac_get_he_phy_cap(phy->mt76, vif);
+	cap = mt76_connac_get_he_phy_cap(phy->mt76, conf->vif);
 
 	tlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_HE_BASIC, sizeof(*he));
 
 	he = (struct bss_info_uni_he *)tlv;
-	he->he_pe_duration = vif->bss_conf.htc_trig_based_pkt_ext;
+	he->he_pe_duration = conf->htc_trig_based_pkt_ext;
 	if (!he->he_pe_duration)
 		he->he_pe_duration = DEFAULT_HE_PE_DURATION;
 
-	he->he_rts_thres = cpu_to_le16(vif->bss_conf.frame_time_rts_th);
+	he->he_rts_thres = cpu_to_le16(conf->frame_time_rts_th);
 	if (!he->he_rts_thres)
 		he->he_rts_thres = cpu_to_le16(DEFAULT_HE_DURATION_RTS_THRES);
 
@@ -992,13 +990,13 @@ mt7996_mcu_bss_he_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
 }
 
 static void
-mt7996_mcu_bss_mbssid_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
+mt7996_mcu_bss_mbssid_tlv(struct sk_buff *skb, struct ieee80211_bss_conf *conf,
 			  struct mt7996_phy *phy, int enable)
 {
 	struct bss_info_uni_mbssid *mbssid;
 	struct tlv *tlv;
 
-	if (!vif->bss_conf.bssid_indicator)
+	if (!conf->bssid_indicator)
 		return;
 
 	tlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_11V_MBSSID, sizeof(*mbssid));
@@ -1006,23 +1004,21 @@ mt7996_mcu_bss_mbssid_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
 	mbssid = (struct bss_info_uni_mbssid *)tlv;
 
 	if (enable) {
-		mbssid->max_indicator = vif->bss_conf.bssid_indicator;
-		mbssid->mbss_idx = vif->bss_conf.bssid_index;
+		mbssid->max_indicator = conf->bssid_indicator;
+		mbssid->mbss_idx = conf->bssid_index;
 		mbssid->tx_bss_omac_idx = 0;
 	}
 }
 
 static void
-mt7996_mcu_bss_bmc_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
+mt7996_mcu_bss_bmc_tlv(struct sk_buff *skb, struct mt7996_bss_conf *mconf,
 		       struct mt7996_phy *phy)
 {
-	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct bss_rate_tlv *bmc;
 	struct cfg80211_chan_def *chandef = &phy->mt76->chandef;
 	enum nl80211_band band = chandef->chan->band;
 	struct tlv *tlv;
-	u8 idx = mvif->mcast_rates_idx ?
-		 mvif->mcast_rates_idx : mvif->basic_rates_idx;
+	u8 idx = mconf->mt76.mcast_rates_idx ?: mconf->mt76.basic_rates_idx;
 
 	tlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_RATE, sizeof(*bmc));
 
@@ -1046,9 +1042,9 @@ mt7996_mcu_bss_txcmd_tlv(struct sk_buff *skb, bool en)
 }
 
 static void
-mt7996_mcu_bss_mld_tlv(struct sk_buff *skb, struct ieee80211_vif *vif)
+mt7996_mcu_bss_mld_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
+		       struct mt7996_bss_conf *mconf)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct bss_mld_tlv *mld;
 	struct tlv *tlv;
 
@@ -1056,33 +1052,30 @@ mt7996_mcu_bss_mld_tlv(struct sk_buff *skb, struct ieee80211_vif *vif)
 
 	mld = (struct bss_mld_tlv *)tlv;
 	mld->group_mld_id = 0xff;
-	mld->own_mld_id = mvif->mt76.idx;
+	mld->own_mld_id = mconf->mt76.idx;
 	mld->remap_idx = 0xff;
 }
 
 static void
-mt7996_mcu_bss_sec_tlv(struct sk_buff *skb, struct ieee80211_vif *vif)
+mt7996_mcu_bss_sec_tlv(struct sk_buff *skb, struct mt7996_bss_conf *mconf)
 {
-	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct bss_sec_tlv *sec;
 	struct tlv *tlv;
 
 	tlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_SEC, sizeof(*sec));
 
 	sec = (struct bss_sec_tlv *)tlv;
-	sec->cipher = mvif->cipher;
+	sec->cipher = mconf->mt76.cipher;
 }
 
 static int
-mt7996_mcu_muar_config(struct mt7996_phy *phy, struct ieee80211_vif *vif,
-		       bool bssid, bool enable)
+mt7996_mcu_muar_config(struct mt7996_phy *phy, struct ieee80211_bss_conf *conf,
+		       struct mt7996_bss_conf *mconf, bool bssid, bool enable)
 {
 #define UNI_MUAR_ENTRY 2
 	struct mt7996_dev *dev = phy->dev;
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	u32 idx = mvif->mt76.omac_idx - REPEATER_BSSID_START;
-	const u8 *addr = vif->addr;
-
+	u32 idx = mconf->mt76.omac_idx - REPEATER_BSSID_START;
+	const u8 *addr = bssid ? conf->bssid : conf->vif->addr;
 	struct {
 		struct {
 			u8 band;
@@ -1107,9 +1100,6 @@ mt7996_mcu_muar_config(struct mt7996_phy *phy, struct ieee80211_vif *vif,
 		.entry_add = true,
 	};
 
-	if (bssid)
-		addr = vif->bss_conf.bssid;
-
 	if (enable)
 		memcpy(req.addr, addr, ETH_ALEN);
 
@@ -1118,10 +1108,8 @@ mt7996_mcu_muar_config(struct mt7996_phy *phy, struct ieee80211_vif *vif,
 }
 
 static void
-mt7996_mcu_bss_ifs_timing_tlv(struct sk_buff *skb, struct ieee80211_vif *vif)
+mt7996_mcu_bss_ifs_timing_tlv(struct sk_buff *skb, struct mt7996_phy *phy)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_phy *phy = mvif->phy;
 	struct bss_ifs_time_tlv *ifs_time;
 	struct tlv *tlv;
 	bool is_2ghz = phy->mt76->chandef.chan->band == NL80211_BAND_2GHZ;
@@ -1147,12 +1135,13 @@ mt7996_mcu_bss_ifs_timing_tlv(struct sk_buff *skb, struct ieee80211_vif *vif)
 
 static int
 mt7996_mcu_bss_basic_tlv(struct sk_buff *skb,
-			 struct ieee80211_vif *vif,
+			 struct ieee80211_bss_conf *conf,
+			 struct mt7996_bss_conf *mconf,
 			 struct ieee80211_sta *sta,
 			 struct mt76_phy *phy, u16 wlan_idx,
 			 bool enable)
 {
-	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
+	struct ieee80211_vif *vif = conf->vif;
 	struct cfg80211_chan_def *chandef = &phy->chandef;
 	struct mt76_connac_bss_basic_tlv *bss;
 	u32 type = CONNECTION_INFRA_AP;
@@ -1169,8 +1158,7 @@ mt7996_mcu_bss_basic_tlv(struct sk_buff *skb,
 		if (enable) {
 			rcu_read_lock();
 			if (!sta)
-				sta = ieee80211_find_sta(vif,
-							 vif->bss_conf.bssid);
+				sta = ieee80211_find_sta(vif, conf->bssid);
 			/* TODO: enable BSS_INFO_UAPSD & BSS_INFO_PM */
 			if (sta) {
 				struct mt76_wcid *wcid;
@@ -1193,18 +1181,17 @@ mt7996_mcu_bss_basic_tlv(struct sk_buff *skb,
 	tlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_BASIC, sizeof(*bss));
 
 	bss = (struct mt76_connac_bss_basic_tlv *)tlv;
-	bss->bcn_interval = cpu_to_le16(vif->bss_conf.beacon_int);
-	bss->dtim_period = vif->bss_conf.dtim_period;
 	bss->bmc_tx_wlan_idx = cpu_to_le16(wlan_idx);
 	bss->sta_idx = cpu_to_le16(sta_wlan_idx);
 	bss->conn_type = cpu_to_le32(type);
-	bss->omac_idx = mvif->omac_idx;
-	bss->band_idx = mvif->band_idx;
-	bss->wmm_idx = mvif->wmm_idx;
+	bss->omac_idx = mconf->mt76.omac_idx;
+	bss->band_idx = mconf->mt76.band_idx;
+	bss->wmm_idx = mconf->mt76.wmm_idx;
 	bss->conn_state = !enable;
 	bss->active = enable;
 
-	idx = mvif->omac_idx > EXT_BSSID_START ? HW_BSSID_0 : mvif->omac_idx;
+	idx = mconf->mt76.omac_idx > EXT_BSSID_START ? HW_BSSID_0 :
+						       mconf->mt76.omac_idx;
 	bss->hw_bss_idx = idx;
 
 	if (vif->type == NL80211_IFTYPE_MONITOR) {
@@ -1217,9 +1204,9 @@ mt7996_mcu_bss_basic_tlv(struct sk_buff *skb,
 		return 0;
 	}
 
-	memcpy(bss->bssid, vif->bss_conf.bssid, ETH_ALEN);
-	bss->bcn_interval = cpu_to_le16(vif->bss_conf.beacon_int);
-	bss->dtim_period = vif->bss_conf.dtim_period;
+	memcpy(bss->bssid, conf->bssid, ETH_ALEN);
+	bss->bcn_interval = cpu_to_le16(conf->beacon_int);
+	bss->dtim_period = conf->dtim_period;
 	bss->phymode = mt76_connac_get_phy_mode(phy, vif,
 						chandef->chan->band, NULL);
 	bss->phymode_ext = mt76_connac_get_phy_mode_ext(phy, vif,
@@ -1246,63 +1233,64 @@ __mt7996_mcu_alloc_bss_req(struct mt76_dev *dev, struct mt76_vif *mvif, int len)
 }
 
 int mt7996_mcu_add_bss_info(struct mt7996_phy *phy,
-			    struct ieee80211_vif *vif, int enable)
+			    struct ieee80211_bss_conf *conf,
+			    struct mt7996_bss_conf *mconf, int enable)
 {
+	struct ieee80211_vif *vif = conf->vif;
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_dev *dev = phy->dev;
 	struct sk_buff *skb;
 
-	if (mvif->mt76.omac_idx >= REPEATER_BSSID_START) {
-		mt7996_mcu_muar_config(phy, vif, false, enable);
-		mt7996_mcu_muar_config(phy, vif, true, enable);
+	if (mconf->mt76.omac_idx >= REPEATER_BSSID_START) {
+		mt7996_mcu_muar_config(phy, conf, mconf, false, enable);
+		mt7996_mcu_muar_config(phy, conf, mconf, true, enable);
 	}
 
-	skb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mvif->mt76,
+	skb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mconf->mt76,
 					 MT7996_BSS_UPDATE_MAX_SIZE);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
 	/* bss_basic must be first */
-	mt7996_mcu_bss_basic_tlv(skb, vif, NULL, phy->mt76,
+	mt7996_mcu_bss_basic_tlv(skb, conf, mconf, NULL, phy->mt76,
 				 mvif->sta.wcid.idx, enable);
-	mt7996_mcu_bss_sec_tlv(skb, vif);
+	mt7996_mcu_bss_sec_tlv(skb, mconf);
 
 	if (vif->type == NL80211_IFTYPE_MONITOR)
 		goto out;
 
 	if (enable) {
-		mt7996_mcu_bss_rfch_tlv(skb, vif, phy);
-		mt7996_mcu_bss_bmc_tlv(skb, vif, phy);
-		mt7996_mcu_bss_ra_tlv(skb, vif, phy);
+		mt7996_mcu_bss_rfch_tlv(skb, phy);
+		mt7996_mcu_bss_bmc_tlv(skb, mconf, phy);
+		mt7996_mcu_bss_ra_tlv(skb);
 		mt7996_mcu_bss_txcmd_tlv(skb, true);
-		mt7996_mcu_bss_ifs_timing_tlv(skb, vif);
+		mt7996_mcu_bss_ifs_timing_tlv(skb, phy);
 
-		if (vif->bss_conf.he_support)
-			mt7996_mcu_bss_he_tlv(skb, vif, phy);
+		if (conf->he_support)
+			mt7996_mcu_bss_he_tlv(skb, conf, phy);
 
 		/* this tag is necessary no matter if the vif is MLD */
-		mt7996_mcu_bss_mld_tlv(skb, vif);
+		mt7996_mcu_bss_mld_tlv(skb, vif, mconf);
 	}
 
-	mt7996_mcu_bss_mbssid_tlv(skb, vif, phy, enable);
+	mt7996_mcu_bss_mbssid_tlv(skb, conf, phy, enable);
 
 out:
 	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
 				     MCU_WMWA_UNI_CMD(BSS_INFO_UPDATE), true);
 }
 
-int mt7996_mcu_set_timing(struct mt7996_phy *phy, struct ieee80211_vif *vif)
+int mt7996_mcu_set_timing(struct mt7996_phy *phy, struct mt7996_bss_conf *mconf)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_dev *dev = phy->dev;
 	struct sk_buff *skb;
 
-	skb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mvif->mt76,
+	skb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mconf->mt76,
 					 MT7996_BSS_UPDATE_MAX_SIZE);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
-	mt7996_mcu_bss_ifs_timing_tlv(skb, vif);
+	mt7996_mcu_bss_ifs_timing_tlv(skb, phy);
 
 	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
 				     MCU_WMWA_UNI_CMD(BSS_INFO_UPDATE), true);
@@ -1344,12 +1332,12 @@ int mt7996_mcu_add_tx_ba(struct mt7996_dev *dev,
 			 bool enable)
 {
 	struct mt7996_sta *msta = (struct mt7996_sta *)params->sta->drv_priv;
-	struct mt7996_vif *mvif = msta->vif;
+	struct mt7996_bss_conf *mconf = mconf_dereference_protected(msta->vif, 0);
 
 	if (enable && !params->amsdu)
 		msta->wcid.amsdu = false;
 
-	return mt7996_mcu_sta_ba(dev, &mvif->mt76, params, enable, true);
+	return mt7996_mcu_sta_ba(dev, &mconf->mt76, params, enable, true);
 }
 
 int mt7996_mcu_add_rx_ba(struct mt7996_dev *dev,
@@ -1357,13 +1345,14 @@ int mt7996_mcu_add_rx_ba(struct mt7996_dev *dev,
 			 bool enable)
 {
 	struct mt7996_sta *msta = (struct mt7996_sta *)params->sta->drv_priv;
-	struct mt7996_vif *mvif = msta->vif;
+	struct mt7996_bss_conf *mconf = mconf_dereference_protected(msta->vif, 0);
 
-	return mt7996_mcu_sta_ba(dev, &mvif->mt76, params, enable, false);
+	return mt7996_mcu_sta_ba(dev, &mconf->mt76, params, enable, false);
 }
 
 static void
-mt7996_mcu_sta_he_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
+mt7996_mcu_sta_he_tlv(struct sk_buff *skb, struct ieee80211_bss_conf *conf,
+		      struct mt7996_bss_conf *mconf,
 		      struct ieee80211_sta *sta)
 {
 	struct ieee80211_he_cap_elem *elem = &sta->deflink.he_cap.he_cap_elem;
@@ -1384,9 +1373,9 @@ mt7996_mcu_sta_he_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
 		he->he_phy_cap[i] = elem->phy_cap_info[i];
 	}
 
-	if (vif->type == NL80211_IFTYPE_AP &&
+	if (conf->vif->type == NL80211_IFTYPE_AP &&
 	    (elem->phy_cap_info[1] & IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD))
-		u8p_replace_bits(&he->he_phy_cap[1], vif->bss_conf.he_ldpc,
+		u8p_replace_bits(&he->he_phy_cap[1], conf->he_ldpc,
 				 IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD);
 
 	mcs_map = sta->deflink.he_cap.he_mcs_nss_supp;
@@ -1394,16 +1383,16 @@ mt7996_mcu_sta_he_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
 	case IEEE80211_STA_RX_BW_160:
 		if (elem->phy_cap_info[0] &
 		    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)
-			mt7996_mcu_set_sta_he_mcs(sta,
+			mt7996_mcu_set_sta_he_mcs(sta, mconf,
 						  &he->max_nss_mcs[CMD_HE_MCS_BW8080],
 						  le16_to_cpu(mcs_map.rx_mcs_80p80));
 
-		mt7996_mcu_set_sta_he_mcs(sta,
+		mt7996_mcu_set_sta_he_mcs(sta, mconf,
 					  &he->max_nss_mcs[CMD_HE_MCS_BW160],
 					  le16_to_cpu(mcs_map.rx_mcs_160));
 		fallthrough;
 	default:
-		mt7996_mcu_set_sta_he_mcs(sta,
+		mt7996_mcu_set_sta_he_mcs(sta, mconf,
 					  &he->max_nss_mcs[CMD_HE_MCS_BW80],
 					  le16_to_cpu(mcs_map.rx_mcs_80));
 		break;
@@ -1494,7 +1483,7 @@ mt7996_mcu_sta_vht_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)
 	struct tlv *tlv;
 #ifdef CONFIG_MTK_VENDOR
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
-	struct mt7996_phy *phy = (struct mt7996_phy *)msta->vif->phy;
+	struct mt7996_phy *phy = (struct mt7996_phy *)msta->vif->deflink.phy;
 #endif
 
 	/* For 6G band, this tlv is necessary to let hw work normally */
@@ -1551,25 +1540,26 @@ mt7996_mcu_sta_amsdu_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 
 static void
 mt7996_mcu_sta_muru_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
-			struct ieee80211_vif *vif, struct ieee80211_sta *sta)
+			struct ieee80211_bss_conf *conf,
+			struct mt7996_bss_conf *mconf,
+			struct ieee80211_sta *sta)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_phy *phy = mvif->phy;
+	struct mt7996_phy *phy = mconf->phy;
 	struct ieee80211_he_cap_elem *elem = &sta->deflink.he_cap.he_cap_elem;
 	struct sta_rec_muru *muru;
 	struct tlv *tlv;
 
-	if (vif->type != NL80211_IFTYPE_STATION &&
-	    vif->type != NL80211_IFTYPE_AP)
+	if (conf->vif->type != NL80211_IFTYPE_STATION &&
+	    conf->vif->type != NL80211_IFTYPE_AP)
 		return;
 
 	tlv = mt76_connac_mcu_add_tlv(skb, STA_REC_MURU, sizeof(*muru));
 
 	muru = (struct sta_rec_muru *)tlv;
-	muru->cfg.mimo_dl_en = (vif->bss_conf.eht_mu_beamformer ||
-				vif->bss_conf.he_mu_beamformer ||
-				vif->bss_conf.vht_mu_beamformer ||
-				vif->bss_conf.vht_mu_beamformee) &&
+	muru->cfg.mimo_dl_en = (conf->eht_mu_beamformer ||
+				conf->he_mu_beamformer ||
+				conf->vht_mu_beamformer ||
+				conf->vht_mu_beamformee) &&
 			       !!(phy->muru_onoff & MUMIMO_DL);
 	muru->cfg.mimo_ul_en = !!(phy->muru_onoff & MUMIMO_UL);
 	muru->cfg.ofdma_dl_en = !!(phy->muru_onoff & OFDMA_DL);
@@ -1610,13 +1600,14 @@ mt7996_mcu_sta_muru_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 }
 
 static inline bool
-mt7996_is_ebf_supported(struct mt7996_phy *phy, struct ieee80211_vif *vif,
+mt7996_is_ebf_supported(struct mt7996_phy *phy, struct ieee80211_bss_conf *conf,
+			struct mt7996_bss_conf *mconf,
 			struct ieee80211_sta *sta, bool bfee)
 {
 	int sts = hweight16(phy->mt76->chainmask);
 
-	if (vif->type != NL80211_IFTYPE_STATION &&
-	    vif->type != NL80211_IFTYPE_AP)
+	if (conf->vif->type != NL80211_IFTYPE_STATION &&
+	    conf->vif->type != NL80211_IFTYPE_AP)
 		return false;
 
 	if (!bfee && sts < 2)
@@ -1627,10 +1618,10 @@ mt7996_is_ebf_supported(struct mt7996_phy *phy, struct ieee80211_vif *vif,
 		struct ieee80211_eht_cap_elem_fixed *pe = &pc->eht_cap_elem;
 
 		if (bfee)
-			return vif->bss_conf.eht_su_beamformee &&
+			return conf->eht_su_beamformee &&
 			       EHT_PHY(CAP0_SU_BEAMFORMEE, pe->phy_cap_info[0]);
 		else
-			return vif->bss_conf.eht_su_beamformer &&
+			return conf->eht_su_beamformer &&
 			       EHT_PHY(CAP0_SU_BEAMFORMER, pe->phy_cap_info[0]);
 	}
 
@@ -1638,10 +1629,10 @@ mt7996_is_ebf_supported(struct mt7996_phy *phy, struct ieee80211_vif *vif,
 		struct ieee80211_he_cap_elem *pe = &sta->deflink.he_cap.he_cap_elem;
 
 		if (bfee)
-			return vif->bss_conf.he_su_beamformee &&
+			return conf->he_su_beamformee &&
 			       HE_PHY(CAP3_SU_BEAMFORMER, pe->phy_cap_info[3]);
 		else
-			return vif->bss_conf.he_su_beamformer &&
+			return conf->he_su_beamformer &&
 			       HE_PHY(CAP4_SU_BEAMFORMEE, pe->phy_cap_info[4]);
 	}
 
@@ -1649,10 +1640,10 @@ mt7996_is_ebf_supported(struct mt7996_phy *phy, struct ieee80211_vif *vif,
 		u32 cap = sta->deflink.vht_cap.cap;
 
 		if (bfee)
-			return vif->bss_conf.vht_su_beamformee &&
+			return conf->vht_su_beamformee &&
 			       (cap & IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE);
 		else
-			return vif->bss_conf.vht_su_beamformer &&
+			return conf->vht_su_beamformer &&
 			       (cap & IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE);
 	}
 
@@ -1848,10 +1839,10 @@ mt7996_mcu_sta_bfer_eht(struct ieee80211_sta *sta, struct ieee80211_vif *vif,
 
 static void
 mt7996_mcu_sta_bfer_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
-			struct ieee80211_vif *vif, struct ieee80211_sta *sta)
+			struct ieee80211_bss_conf *conf, struct mt7996_bss_conf *mconf,
+			struct ieee80211_sta *sta)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_phy *phy = mvif->phy;
+	struct mt7996_phy *phy = mconf->phy;
 	int tx_ant = hweight8(phy->mt76->chainmask) - 1;
 	struct sta_rec_bf *bf;
 	struct tlv *tlv;
@@ -1866,7 +1857,7 @@ mt7996_mcu_sta_bfer_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 	if (!(sta->deflink.ht_cap.ht_supported || sta->deflink.he_cap.has_he))
 		return;
 
-	ebf = mt7996_is_ebf_supported(phy, vif, sta, false);
+	ebf = mt7996_is_ebf_supported(phy, conf, mconf, sta, false);
 	if (!ebf && !dev->ibf)
 		return;
 
@@ -1878,9 +1869,9 @@ mt7996_mcu_sta_bfer_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 	 * ht: iBF only, since mac80211 lacks of eBF support
 	 */
 	if (sta->deflink.eht_cap.has_eht && ebf)
-		mt7996_mcu_sta_bfer_eht(sta, vif, phy, bf);
+		mt7996_mcu_sta_bfer_eht(sta, conf->vif, phy, bf);
 	else if (sta->deflink.he_cap.has_he && ebf)
-		mt7996_mcu_sta_bfer_he(sta, vif, phy, bf);
+		mt7996_mcu_sta_bfer_he(sta, conf->vif, phy, bf);
 	else if (sta->deflink.vht_cap.vht_supported)
 		mt7996_mcu_sta_bfer_vht(sta, phy, bf, ebf);
 	else if (sta->deflink.ht_cap.ht_supported)
@@ -1919,10 +1910,10 @@ mt7996_mcu_sta_bfer_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 
 static void
 mt7996_mcu_sta_bfee_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
-			struct ieee80211_vif *vif, struct ieee80211_sta *sta)
+			struct ieee80211_bss_conf *conf,
+			struct mt7996_bss_conf *mconf, struct ieee80211_sta *sta)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_phy *phy = mvif->phy;
+	struct mt7996_phy *phy = mconf->phy;
 	int tx_ant = hweight8(phy->mt76->antenna_mask) - 1;
 	struct sta_rec_bfee *bfee;
 	struct tlv *tlv;
@@ -1931,7 +1922,7 @@ mt7996_mcu_sta_bfee_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 	if (!(sta->deflink.vht_cap.vht_supported || sta->deflink.he_cap.has_he))
 		return;
 
-	if (!mt7996_is_ebf_supported(phy, vif, sta, true))
+	if (!mt7996_is_ebf_supported(phy, conf, mconf, sta, false))
 		return;
 
 	tlv = mt76_connac_mcu_add_tlv(skb, STA_REC_BFEE, sizeof(*bfee));
@@ -2053,17 +2044,17 @@ int mt7996_mcu_set_fixed_rate_ctrl(struct mt7996_dev *dev,
 				     MCU_WM_UNI_CMD(RA), true);
 }
 
-int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev, struct ieee80211_vif *vif,
+int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev,
+			       struct mt7996_bss_conf *mconf,
 			       struct ieee80211_sta *sta, void *data, u32 field)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
 	struct sta_phy_uni *phy = data;
 	struct sta_rec_ra_fixed_uni *ra;
 	struct sk_buff *skb;
 	struct tlv *tlv;
 
-	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,
+	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mconf->mt76,
 					      &msta->wcid,
 					      MT7996_STA_UPDATE_MAX_SIZE);
 	if (IS_ERR(skb))
@@ -2095,12 +2086,13 @@ int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev, struct ieee80211_vif *vif
 }
 
 static int
-mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev, struct ieee80211_vif *vif,
+mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev,
+			       struct ieee80211_bss_conf *conf,
+			       struct mt7996_bss_conf *mconf,
 			       struct ieee80211_sta *sta)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct cfg80211_chan_def *chandef = &mvif->phy->mt76->chandef;
-	struct cfg80211_bitrate_mask *mask = &mvif->bitrate_mask;
+	struct cfg80211_chan_def *chandef = &mconf->phy->mt76->chandef;
+	struct cfg80211_bitrate_mask *mask = &mconf->bitrate_mask;
 	enum nl80211_band band = chandef->chan->band;
 	struct sta_phy_uni phy = {};
 	int ret, nrates = 0;
@@ -2142,7 +2134,7 @@ mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev, struct ieee80211_vif *vif
 
 	/* fixed single rate */
 	if (nrates == 1) {
-		ret = mt7996_mcu_set_fixed_field(dev, vif, sta, &phy,
+		ret = mt7996_mcu_set_fixed_field(dev, mconf, sta, &phy,
 						 RATE_PARAM_FIXED_MCS);
 		if (ret)
 			return ret;
@@ -2164,7 +2156,7 @@ mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev, struct ieee80211_vif *vif
 		else
 			mt76_rmw_field(dev, addr, GENMASK(15, 12), phy.sgi);
 
-		ret = mt7996_mcu_set_fixed_field(dev, vif, sta, &phy,
+		ret = mt7996_mcu_set_fixed_field(dev, mconf, sta, &phy,
 						 RATE_PARAM_FIXED_GI);
 		if (ret)
 			return ret;
@@ -2172,7 +2164,7 @@ mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev, struct ieee80211_vif *vif
 
 	/* fixed HE_LTF */
 	if (mask->control[band].he_ltf != GENMASK(7, 0)) {
-		ret = mt7996_mcu_set_fixed_field(dev, vif, sta, &phy,
+		ret = mt7996_mcu_set_fixed_field(dev, mconf, sta, &phy,
 						 RATE_PARAM_FIXED_HE_LTF);
 		if (ret)
 			return ret;
@@ -2183,13 +2175,14 @@ mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev, struct ieee80211_vif *vif
 
 static void
 mt7996_mcu_sta_rate_ctrl_tlv(struct sk_buff *skb, struct mt7996_dev *dev,
-			     struct ieee80211_vif *vif, struct ieee80211_sta *sta)
+			     struct ieee80211_bss_conf *conf,
+			     struct mt7996_bss_conf *mconf,
+			     struct ieee80211_sta *sta)
 {
 #define INIT_RCPI 180
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt76_phy *mphy = mvif->phy->mt76;
+	struct mt76_phy *mphy = mconf->phy->mt76;
 	struct cfg80211_chan_def *chandef = &mphy->chandef;
-	struct cfg80211_bitrate_mask *mask = &mvif->bitrate_mask;
+	struct cfg80211_bitrate_mask *mask = &mconf->bitrate_mask;
 	enum nl80211_band band = chandef->chan->band;
 	struct sta_rec_ra_uni *ra;
 	struct tlv *tlv;
@@ -2201,7 +2194,7 @@ mt7996_mcu_sta_rate_ctrl_tlv(struct sk_buff *skb, struct mt7996_dev *dev,
 
 	ra->valid = true;
 	ra->auto_rate = true;
-	ra->phy_mode = mt76_connac_get_phy_mode(mphy, vif, band, sta);
+	ra->phy_mode = mt76_connac_get_phy_mode(mphy, conf->vif, band, sta);
 	ra->channel = chandef->chan->hw_value;
 	ra->bw = (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_320) ?
 		 CMD_CBW_320MHZ : sta->deflink.bandwidth;
@@ -2240,7 +2233,7 @@ mt7996_mcu_sta_rate_ctrl_tlv(struct sk_buff *skb, struct mt7996_dev *dev,
 			cap |= STA_CAP_TX_STBC;
 		if (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_RX_STBC)
 			cap |= STA_CAP_RX_STBC;
-		if (vif->bss_conf.ht_ldpc &&
+		if (conf->ht_ldpc &&
 		    (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_LDPC_CODING))
 			cap |= STA_CAP_LDPC;
 
@@ -2266,7 +2259,7 @@ mt7996_mcu_sta_rate_ctrl_tlv(struct sk_buff *skb, struct mt7996_dev *dev,
 			cap |= STA_CAP_VHT_TX_STBC;
 		if (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_RXSTBC_1)
 			cap |= STA_CAP_VHT_RX_STBC;
-		if (vif->bss_conf.vht_ldpc &&
+		if (conf->vht_ldpc &&
 		    (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_RXLDPC))
 			cap |= STA_CAP_VHT_LDPC;
 
@@ -2287,15 +2280,16 @@ mt7996_mcu_sta_rate_ctrl_tlv(struct sk_buff *skb, struct mt7996_dev *dev,
 	memset(ra->rx_rcpi, INIT_RCPI, sizeof(ra->rx_rcpi));
 }
 
-int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev, struct ieee80211_vif *vif,
+int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,
+			     struct ieee80211_bss_conf *conf,
+			     struct mt7996_bss_conf *mconf,
 			     struct ieee80211_sta *sta, bool changed)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
 	struct sk_buff *skb;
 	int ret;
 
-	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,
+	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mconf->mt76,
 					      &msta->wcid,
 					      MT7996_STA_UPDATE_MAX_SIZE);
 	if (IS_ERR(skb))
@@ -2306,26 +2300,27 @@ int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 	 * update sta_rec_he here.
 	 */
 	if (changed)
-		mt7996_mcu_sta_he_tlv(skb, vif, sta);
+		mt7996_mcu_sta_he_tlv(skb, conf, mconf, sta);
 
 	/* sta_rec_ra accommodates BW, NSS and only MCS range format
 	 * i.e 0-{7,8,9} for VHT.
 	 */
-	mt7996_mcu_sta_rate_ctrl_tlv(skb, dev, vif, sta);
+	mt7996_mcu_sta_rate_ctrl_tlv(skb, dev, conf, mconf, sta);
 
 	ret = mt76_mcu_skb_send_msg(&dev->mt76, skb,
 				    MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);
 	if (ret)
 		return ret;
 
-	return mt7996_mcu_add_rate_ctrl_fixed(dev, vif, sta);
+	return mt7996_mcu_add_rate_ctrl_fixed(dev, conf, mconf, sta);
 }
 
 static int
-mt7996_mcu_sta_init_vow(struct mt7996_phy *phy, struct mt7996_sta *msta)
+mt7996_mcu_sta_init_vow(struct mt7996_bss_conf *mconf, struct mt7996_sta *msta)
 {
+	struct mt7996_phy *phy = mconf->phy;
 	struct mt7996_vow_sta_ctrl *vow = &msta->vow;
-	u8 omac_idx = msta->vif->mt76.omac_idx;
+	u8 omac_idx = mconf->mt76.omac_idx;
 	int ret;
 
 	/* Assignment of STA BSS group index aligns FW.
@@ -2342,20 +2337,22 @@ mt7996_mcu_sta_init_vow(struct mt7996_phy *phy, struct mt7996_sta *msta)
 	vow->drr_quantum[IEEE80211_AC_BE] = VOW_DRR_QUANTUM_IDX2;
 	vow->drr_quantum[IEEE80211_AC_BK] = VOW_DRR_QUANTUM_IDX2;
 
-	ret = mt7996_mcu_set_vow_drr_ctrl(phy, msta, VOW_DRR_CTRL_STA_BSS_GROUP);
+	ret = mt7996_mcu_set_vow_drr_ctrl(phy, mconf, msta, VOW_DRR_CTRL_STA_BSS_GROUP);
 	if (ret)
 		return ret;
 
-	ret = mt7996_mcu_set_vow_drr_ctrl(phy, msta, VOW_DRR_CTRL_STA_PAUSE);
+	ret = mt7996_mcu_set_vow_drr_ctrl(phy, mconf, msta, VOW_DRR_CTRL_STA_PAUSE);
 	if (ret)
 		return ret;
 
-	return mt7996_mcu_set_vow_drr_ctrl(phy, msta, VOW_DRR_CTRL_STA_ALL);
+	return mt7996_mcu_set_vow_drr_ctrl(phy, mconf, msta, VOW_DRR_CTRL_STA_ALL);
 }
 
-int mt7996_mcu_add_sta(struct mt7996_dev *dev, struct ieee80211_vif *vif,
-		       struct ieee80211_sta *sta, bool enable, bool newly)
+int mt7996_mcu_add_sta(struct mt7996_dev *dev, struct ieee80211_bss_conf *conf,
+		       struct mt7996_bss_conf *mconf, struct ieee80211_sta *sta,
+		       bool enable, bool newly)
 {
+	struct ieee80211_vif *vif = conf->vif;
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_sta *msta;
 	struct sk_buff *skb;
@@ -2363,7 +2360,7 @@ int mt7996_mcu_add_sta(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 
 	msta = sta ? (struct mt7996_sta *)sta->drv_priv : &mvif->sta;
 
-	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,
+	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mconf->mt76,
 					      &msta->wcid,
 					      MT7996_STA_UPDATE_MAX_SIZE);
 	if (IS_ERR(skb))
@@ -2385,7 +2382,7 @@ int mt7996_mcu_add_sta(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 		/* starec hdrt mode */
 		mt7996_mcu_sta_hdrt_tlv(dev, skb);
 		/* starec bfer */
-		mt7996_mcu_sta_bfer_tlv(dev, skb, vif, sta);
+		mt7996_mcu_sta_bfer_tlv(dev, skb, conf, mconf, sta);
 		/* starec ht */
 		mt7996_mcu_sta_ht_tlv(skb, sta);
 		/* starec vht */
@@ -2395,18 +2392,18 @@ int mt7996_mcu_add_sta(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 		/* starec amsdu */
 		mt7996_mcu_sta_amsdu_tlv(dev, skb, vif, sta);
 		/* starec he */
-		mt7996_mcu_sta_he_tlv(skb, vif, sta);
+		mt7996_mcu_sta_he_tlv(skb, conf, mconf, sta);
 		/* starec he 6g*/
 		mt7996_mcu_sta_he_6g_tlv(skb, sta);
 		/* starec eht */
 		mt7996_mcu_sta_eht_tlv(skb, sta);
 		/* starec muru */
-		mt7996_mcu_sta_muru_tlv(dev, skb, vif, sta);
+		mt7996_mcu_sta_muru_tlv(dev, skb, conf, mconf, sta);
 		/* starec bfee */
-		mt7996_mcu_sta_bfee_tlv(dev, skb, vif, sta);
+		mt7996_mcu_sta_bfee_tlv(dev, skb, conf, mconf, sta);
 	}
 
-	ret = mt7996_mcu_sta_init_vow(mvif->phy, msta);
+	ret = mt7996_mcu_sta_init_vow(mconf, msta);
 	if (ret) {
 		dev_kfree_skb(skb);
 		return ret;
@@ -2461,16 +2458,15 @@ mt7996_mcu_sta_key_tlv(struct mt76_wcid *wcid,
 	return 0;
 }
 
-int mt7996_mcu_add_key(struct mt76_dev *dev, struct ieee80211_vif *vif,
+int mt7996_mcu_add_key(struct mt76_dev *dev, struct mt7996_bss_conf *mconf,
 		       struct ieee80211_key_conf *key, int mcu_cmd,
 		       struct mt76_wcid *wcid, enum set_key_cmd cmd)
 {
-	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct sk_buff *skb;
 	int ret;
 
-	skb = __mt76_connac_mcu_alloc_sta_req(dev, mvif, wcid,
-					      MT7996_STA_UPDATE_MAX_SIZE);
+	skb = __mt76_connac_mcu_alloc_sta_req(dev, (struct mt76_vif *)mconf,
+					      wcid, MT7996_STA_UPDATE_MAX_SIZE);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
@@ -2481,17 +2477,18 @@ int mt7996_mcu_add_key(struct mt76_dev *dev, struct ieee80211_vif *vif,
 	return mt76_mcu_skb_send_msg(dev, skb, mcu_cmd, true);
 }
 
-static int mt7996_mcu_get_pn(struct mt7996_dev *dev, struct ieee80211_vif *vif,
-			     u8 *pn)
+static int mt7996_mcu_get_pn(struct mt7996_dev *dev,
+			     struct ieee80211_bss_conf *conf,
+			     struct mt7996_bss_conf *mconf, u8 *pn)
 {
 #define TSC_TYPE_BIGTK_PN 2
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)conf->vif->drv_priv;
 	struct sta_rec_pn_info *pn_info;
 	struct sk_buff *skb, *rskb;
 	struct tlv *tlv;
 	int ret;
 
-	skb = mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76, &mvif->sta.wcid);
+	skb = mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mconf->mt76, &mvif->sta.wcid);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
@@ -2515,10 +2512,11 @@ static int mt7996_mcu_get_pn(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 	return 0;
 }
 
-int mt7996_mcu_bcn_prot_enable(struct mt7996_dev *dev, struct ieee80211_vif *vif,
+int mt7996_mcu_bcn_prot_enable(struct mt7996_dev *dev,
+			       struct ieee80211_bss_conf *conf,
+			       struct mt7996_bss_conf *mconf,
 			       struct ieee80211_key_conf *key)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_mcu_bcn_prot_tlv *bcn_prot;
 	struct sk_buff *skb;
 	struct tlv *tlv;
@@ -2527,7 +2525,7 @@ int mt7996_mcu_bcn_prot_enable(struct mt7996_dev *dev, struct ieee80211_vif *vif
 		  sizeof(struct mt7996_mcu_bcn_prot_tlv);
 	int ret;
 
-	skb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mvif->mt76, len);
+	skb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mconf->mt76, len);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
@@ -2535,7 +2533,7 @@ int mt7996_mcu_bcn_prot_enable(struct mt7996_dev *dev, struct ieee80211_vif *vif
 
 	bcn_prot = (struct mt7996_mcu_bcn_prot_tlv *)tlv;
 
-	ret = mt7996_mcu_get_pn(dev, vif, pn);
+	ret = mt7996_mcu_get_pn(dev, conf, mconf, pn);
 	if (ret) {
 		dev_kfree_skb(skb);
 		return ret;
@@ -2568,10 +2566,10 @@ int mt7996_mcu_bcn_prot_enable(struct mt7996_dev *dev, struct ieee80211_vif *vif
 				     MCU_WMWA_UNI_CMD(BSS_INFO_UPDATE), true);
 }
 int mt7996_mcu_add_dev_info(struct mt7996_phy *phy,
-			    struct ieee80211_vif *vif, bool enable)
+			    struct ieee80211_bss_conf *conf,
+			    struct mt7996_bss_conf *mconf, bool enable)
 {
 	struct mt7996_dev *dev = phy->dev;
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct {
 		struct req_hdr {
 			u8 omac_idx;
@@ -2587,8 +2585,8 @@ int mt7996_mcu_add_dev_info(struct mt7996_phy *phy,
 		} __packed tlv;
 	} data = {
 		.hdr = {
-			.omac_idx = mvif->mt76.omac_idx,
-			.band_idx = mvif->mt76.band_idx,
+			.omac_idx = mconf->mt76.omac_idx,
+			.band_idx = mconf->mt76.band_idx,
 		},
 		.tlv = {
 			.tag = cpu_to_le16(DEV_INFO_ACTIVE),
@@ -2597,16 +2595,16 @@ int mt7996_mcu_add_dev_info(struct mt7996_phy *phy,
 		},
 	};
 
-	if (mvif->mt76.omac_idx >= REPEATER_BSSID_START)
-		return mt7996_mcu_muar_config(phy, vif, false, enable);
+	if (mconf->mt76.omac_idx >= REPEATER_BSSID_START)
+		return mt7996_mcu_muar_config(phy, conf, mconf, false, enable);
 
-	memcpy(data.tlv.omac_addr, vif->addr, ETH_ALEN);
+	memcpy(data.tlv.omac_addr, conf->addr, ETH_ALEN);
 	return mt76_mcu_send_msg(&dev->mt76, MCU_WMWA_UNI_CMD(DEV_INFO_UPDATE),
 				 &data, sizeof(data), true);
 }
 
 static void
-mt7996_mcu_beacon_cntdwn(struct ieee80211_vif *vif, struct sk_buff *rskb,
+mt7996_mcu_beacon_cntdwn(struct ieee80211_bss_conf *conf, struct sk_buff *rskb,
 			 struct sk_buff *skb,
 			 struct ieee80211_mutable_offsets *offs)
 {
@@ -2617,7 +2615,7 @@ mt7996_mcu_beacon_cntdwn(struct ieee80211_vif *vif, struct sk_buff *rskb,
 	if (!offs->cntdwn_counter_offs[0])
 		return;
 
-	tag = vif->bss_conf.csa_active ? UNI_BSS_INFO_BCN_CSA : UNI_BSS_INFO_BCN_BCC;
+	tag = conf->csa_active ? UNI_BSS_INFO_BCN_CSA : UNI_BSS_INFO_BCN_BCC;
 
 	tlv = mt7996_mcu_add_uni_tlv(rskb, tag, sizeof(*info));
 
@@ -2627,14 +2625,15 @@ mt7996_mcu_beacon_cntdwn(struct ieee80211_vif *vif, struct sk_buff *rskb,
 
 static void
 mt7996_mcu_beacon_mbss(struct sk_buff *rskb, struct sk_buff *skb,
-		       struct ieee80211_vif *vif, struct bss_bcn_content_tlv *bcn,
+		       struct ieee80211_bss_conf *conf,
+		       struct bss_bcn_content_tlv *bcn,
 		       struct ieee80211_mutable_offsets *offs)
 {
 	struct bss_bcn_mbss_tlv *mbss;
 	const struct element *elem;
 	struct tlv *tlv;
 
-	if (!vif->bss_conf.bssid_indicator)
+	if (!conf->bssid_indicator)
 		return;
 
 	tlv = mt7996_mcu_add_uni_tlv(rskb, UNI_BSS_INFO_BCN_MBSSID, sizeof(*mbss));
@@ -2679,7 +2678,7 @@ mt7996_mcu_beacon_mbss(struct sk_buff *rskb, struct sk_buff *skb,
 }
 
 static void
-mt7996_mcu_beacon_cont(struct mt7996_dev *dev, struct ieee80211_vif *vif,
+mt7996_mcu_beacon_cont(struct mt7996_dev *dev, struct ieee80211_bss_conf *conf,
 		       struct sk_buff *rskb, struct sk_buff *skb,
 		       struct bss_bcn_content_tlv *bcn,
 		       struct ieee80211_mutable_offsets *offs)
@@ -2693,9 +2692,9 @@ mt7996_mcu_beacon_cont(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 	if (offs->cntdwn_counter_offs[0]) {
 		u16 offset = offs->cntdwn_counter_offs[0];
 
-		if (vif->bss_conf.csa_active)
+		if (conf->csa_active)
 			bcn->csa_ie_pos = cpu_to_le16(offset - 4);
-		if (vif->bss_conf.color_change_active)
+		if (conf->color_change_active)
 			bcn->bcc_ie_pos = cpu_to_le16(offset - 3);
 	}
 
@@ -2707,11 +2706,11 @@ mt7996_mcu_beacon_cont(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 }
 
 int mt7996_mcu_add_beacon(struct ieee80211_hw *hw,
-			  struct ieee80211_vif *vif, int en)
+			  struct ieee80211_bss_conf *conf,
+			  struct mt7996_bss_conf *mconf, int en)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_phy *phy = mt7996_hw_phy(hw);
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct ieee80211_mutable_offsets offs;
 	struct ieee80211_tx_info *info;
 	struct sk_buff *skb, *rskb;
@@ -2719,15 +2718,15 @@ int mt7996_mcu_add_beacon(struct ieee80211_hw *hw,
 	struct bss_bcn_content_tlv *bcn;
 	int len;
 
-	if (vif->bss_conf.nontransmitted)
+	if (conf->nontransmitted)
 		return 0;
 
-	rskb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mvif->mt76,
+	rskb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mconf->mt76,
 					  MT7996_MAX_BSS_OFFLOAD_SIZE);
 	if (IS_ERR(rskb))
 		return PTR_ERR(rskb);
 
-	skb = ieee80211_beacon_get_template(hw, vif, &offs, 0);
+	skb = ieee80211_beacon_get_template(hw, conf->vif, &offs, 0);
 	if (!skb) {
 		dev_kfree_skb(rskb);
 		return -EINVAL;
@@ -2750,9 +2749,9 @@ int mt7996_mcu_add_beacon(struct ieee80211_hw *hw,
 	if (!en)
 		goto out;
 
-	mt7996_mcu_beacon_cont(dev, vif, rskb, skb, bcn, &offs);
-	mt7996_mcu_beacon_mbss(rskb, skb, vif, bcn, &offs);
-	mt7996_mcu_beacon_cntdwn(vif, rskb, skb, &offs);
+	mt7996_mcu_beacon_cont(dev, conf, rskb, skb, bcn, &offs);
+	mt7996_mcu_beacon_mbss(rskb, skb, conf, bcn, &offs);
+	mt7996_mcu_beacon_cntdwn(conf, rskb, skb, &offs);
 out:
 	dev_kfree_skb(skb);
 	return mt76_mcu_skb_send_msg(&phy->dev->mt76, rskb,
@@ -2760,14 +2759,15 @@ out:
 }
 
 int mt7996_mcu_beacon_inband_discov(struct mt7996_dev *dev,
-				    struct ieee80211_vif *vif, u32 changed)
+				    struct ieee80211_bss_conf *conf,
+				    struct mt7996_bss_conf *mconf, u32 changed)
 {
 #define OFFLOAD_TX_MODE_SU	BIT(0)
 #define OFFLOAD_TX_MODE_MU	BIT(1)
 	struct ieee80211_hw *hw = mt76_hw(dev);
+	struct ieee80211_vif *vif = conf->vif;
 	struct mt7996_phy *phy = mt7996_hw_phy(hw);
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct cfg80211_chan_def *chandef = &mvif->phy->mt76->chandef;
+	struct cfg80211_chan_def *chandef = &mconf->phy->mt76->chandef;
 	enum nl80211_band band = chandef->chan->band;
 	struct mt76_wcid *wcid = &dev->mt76.global_wcid;
 	struct bss_inband_discovery_tlv *discov;
@@ -2777,20 +2777,20 @@ int mt7996_mcu_beacon_inband_discov(struct mt7996_dev *dev,
 	u8 *buf, interval;
 	int len;
 
-	if (vif->bss_conf.nontransmitted)
+	if (conf->nontransmitted)
 		return 0;
 
-	rskb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mvif->mt76,
+	rskb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mconf->mt76,
 					  MT7996_MAX_BSS_OFFLOAD_SIZE);
 	if (IS_ERR(rskb))
 		return PTR_ERR(rskb);
 
 	if (changed & BSS_CHANGED_FILS_DISCOVERY) {
-		interval = vif->bss_conf.fils_discovery.max_interval;
+		interval = conf->fils_discovery.max_interval;
 		skb = ieee80211_get_fils_discovery_tmpl(hw, vif);
 	} else if (changed & BSS_CHANGED_UNSOL_BCAST_PROBE_RESP &&
-		   vif->bss_conf.unsol_bcast_probe_resp_interval) {
-		interval = vif->bss_conf.unsol_bcast_probe_resp_interval;
+		   conf->unsol_bcast_probe_resp_interval) {
+		interval = conf->unsol_bcast_probe_resp_interval;
 		skb = ieee80211_get_unsol_bcast_probe_resp_tmpl(hw, vif);
 	}
 
@@ -3424,7 +3424,7 @@ int mt7996_mcu_set_hdr_trans(struct mt7996_dev *dev, bool hdr_trans)
 				     MCU_WM_UNI_CMD(RX_HDR_TRANS), true);
 }
 
-int mt7996_mcu_set_tx(struct mt7996_dev *dev, struct ieee80211_vif *vif)
+int mt7996_mcu_set_tx(struct mt7996_dev *dev, struct mt7996_bss_conf *mconf)
 {
 #define MCU_EDCA_AC_PARAM	0
 #define WMM_AIFS_SET		BIT(0)
@@ -3433,12 +3433,11 @@ int mt7996_mcu_set_tx(struct mt7996_dev *dev, struct ieee80211_vif *vif)
 #define WMM_TXOP_SET		BIT(3)
 #define WMM_PARAM_SET		(WMM_AIFS_SET | WMM_CW_MIN_SET | \
 				 WMM_CW_MAX_SET | WMM_TXOP_SET)
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct {
 		u8 bss_idx;
 		u8 __rsv[3];
 	} __packed hdr = {
-		.bss_idx = mvif->mt76.idx,
+		.bss_idx = mconf->mt76.idx,
 	};
 	struct sk_buff *skb;
 	int len = sizeof(hdr) + IEEE80211_NUM_ACS * sizeof(struct edca);
@@ -3451,7 +3450,7 @@ int mt7996_mcu_set_tx(struct mt7996_dev *dev, struct ieee80211_vif *vif)
 	skb_put_data(skb, &hdr, sizeof(hdr));
 
 	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
-		struct ieee80211_tx_queue_params *q = &mvif->queue_params[ac];
+		struct ieee80211_tx_queue_params *q = &mconf->queue_params[ac];
 		struct edca *e;
 		struct tlv *tlv;
 
@@ -4479,12 +4478,12 @@ mt7996_mcu_set_obss_spr_pd(struct mt7996_phy *phy,
 }
 
 static int
-mt7996_mcu_set_obss_spr_siga(struct mt7996_phy *phy, struct ieee80211_vif *vif,
+mt7996_mcu_set_obss_spr_siga(struct mt7996_phy *phy,
+			     struct mt7996_bss_conf *mconf,
 			     struct ieee80211_he_obss_pd *he_obss_pd)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_dev *dev = phy->dev;
-	u8 omac = mvif->mt76.omac_idx;
+	u8 omac = mconf->mt76.omac_idx;
 	struct {
 		u8 band_idx;
 		u8 __rsv[3];
@@ -4556,7 +4555,8 @@ mt7996_mcu_set_obss_spr_bitmap(struct mt7996_phy *phy,
 				 sizeof(req), true);
 }
 
-int mt7996_mcu_add_obss_spr(struct mt7996_phy *phy, struct ieee80211_vif *vif,
+int mt7996_mcu_add_obss_spr(struct mt7996_phy *phy,
+			    struct mt7996_bss_conf *mconf,
 			    struct ieee80211_he_obss_pd *he_obss_pd)
 {
 	int ret;
@@ -4590,7 +4590,7 @@ int mt7996_mcu_add_obss_spr(struct mt7996_phy *phy, struct ieee80211_vif *vif,
 		return ret;
 
 	/* Set SR prohibit */
-	ret = mt7996_mcu_set_obss_spr_siga(phy, vif, he_obss_pd);
+	ret = mt7996_mcu_set_obss_spr_siga(phy, mconf, he_obss_pd);
 	if (ret)
 		return ret;
 
@@ -4598,16 +4598,16 @@ int mt7996_mcu_add_obss_spr(struct mt7996_phy *phy, struct ieee80211_vif *vif,
 	return mt7996_mcu_set_obss_spr_bitmap(phy, he_obss_pd);
 }
 
-int mt7996_mcu_update_bss_color(struct mt7996_dev *dev, struct ieee80211_vif *vif,
+int mt7996_mcu_update_bss_color(struct mt7996_dev *dev,
+				struct mt7996_bss_conf *mconf,
 				struct cfg80211_he_bss_color *he_bss_color)
 {
 	int len = sizeof(struct bss_req_hdr) + sizeof(struct bss_color_tlv);
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct bss_color_tlv *bss_color;
 	struct sk_buff *skb;
 	struct tlv *tlv;
 
-	skb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mvif->mt76, len);
+	skb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mconf->mt76, len);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
@@ -4626,7 +4626,7 @@ int mt7996_mcu_update_bss_color(struct mt7996_dev *dev, struct ieee80211_vif *vi
 #define TWT_AGRT_PROTECT	BIT(2)
 
 int mt7996_mcu_twt_agrt_update(struct mt7996_dev *dev,
-			       struct mt7996_vif *mvif,
+			       struct mt7996_bss_conf *mconf,
 			       struct mt7996_twt_flow *flow,
 			       int cmd)
 {
@@ -4657,12 +4657,12 @@ int mt7996_mcu_twt_agrt_update(struct mt7996_dev *dev,
 		.len = cpu_to_le16(sizeof(req) - 4),
 		.tbl_idx = flow->table_id,
 		.cmd = cmd,
-		.own_mac_idx = mvif->mt76.omac_idx,
+		.own_mac_idx = mconf->mt76.omac_idx,
 		.flowid = flow->id,
 		.peer_id = cpu_to_le16(flow->wcid),
 		.duration = flow->duration,
-		.bss = mvif->mt76.idx,
-		.bss_idx = mvif->mt76.idx,
+		.bss = mconf->mt76.idx,
+		.bss_idx = mconf->mt76.idx,
 		.start_tsf = cpu_to_le64(flow->tsf),
 		.mantissa = flow->mantissa,
 		.exponent = flow->exp,
@@ -4793,15 +4793,15 @@ int mt7996_mcu_rdd_background_disable_timer(struct mt7996_dev *dev, bool disable
 
 int mt7996_mcu_wtbl_update_hdr_trans(struct mt7996_dev *dev,
 				     struct ieee80211_vif *vif,
+				     struct mt7996_bss_conf *mconf,
 				     struct ieee80211_sta *sta)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_sta *msta;
 	struct sk_buff *skb;
 
-	msta = sta ? (struct mt7996_sta *)sta->drv_priv : &mvif->sta;
+	msta = sta ? (struct mt7996_sta *)sta->drv_priv : &mconf->vif->sta;
 
-	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,
+	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mconf->mt76,
 					      &msta->wcid,
 					      MT7996_STA_UPDATE_MAX_SIZE);
 	if (IS_ERR(skb))
@@ -5435,8 +5435,9 @@ int mt7996_mcu_set_scs(struct mt7996_phy *phy, u8 enable)
 				 &req, sizeof(req), false);
 }
 
-int mt7996_mcu_set_vow_drr_ctrl(struct mt7996_phy *phy, struct mt7996_sta *msta,
-	                        enum vow_drr_ctrl_id id)
+int mt7996_mcu_set_vow_drr_ctrl(struct mt7996_phy *phy,
+				struct mt7996_bss_conf *mconf,
+				struct mt7996_sta *msta, enum vow_drr_ctrl_id id)
 {
 	struct mt7996_vow_sta_ctrl *vow = msta ? &msta->vow : NULL;
 	u32 val = 0;
@@ -5462,9 +5463,9 @@ int mt7996_mcu_set_vow_drr_ctrl(struct mt7996_phy *phy, struct mt7996_sta *msta,
 		.len = cpu_to_le16(sizeof(req) - 4),
 		.wlan_idx = cpu_to_le16(msta ? msta->wcid.idx : 0),
 		.band_idx = phy->mt76->band_idx,
-		.wmm_idx = msta ? msta->vif->mt76.wmm_idx : 0,
+		.wmm_idx = msta ? mconf->mt76.wmm_idx : 0,
 		.ctrl_id = cpu_to_le32(id),
-		.omac_idx = msta ? msta->vif->mt76.omac_idx : 0
+		.omac_idx = msta ? mconf->mt76.omac_idx : 0
 	};
 
 	switch (id) {
@@ -5652,7 +5653,7 @@ void mt7996_set_wireless_vif(void *data, u8 *mac, struct ieee80211_vif *vif)
 {
 	u8 mode, val;
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_phy *phy =  mvif->phy;
+	struct mt7996_phy *phy =  mvif->deflink.phy;
 
 	mode = FIELD_GET(RATE_CFG_MODE, *((u32 *)data));
 	val = FIELD_GET(RATE_CFG_VAL, *((u32 *)data));
@@ -5683,11 +5684,11 @@ void mt7996_set_wireless_vif(void *data, u8 *mac, struct ieee80211_vif *vif)
 void mt7996_set_beacon_vif(void *data, u8 *mac, struct ieee80211_vif *vif)
 {
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct ieee80211_hw *hw = mvif->phy->mt76->hw;
+	struct ieee80211_hw *hw = mvif->deflink.phy->mt76->hw;
 	u8 val = *((u8 *)data);
 
 	vif->bss_conf.enable_beacon = val;
 
-	mt7996_mcu_add_beacon(hw, vif, val);
+	mt7996_mcu_add_beacon(hw, &vif->bss_conf, &mvif->deflink, val);
 }
 #endif
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index 110979452..0fa2aaf7e 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -325,18 +325,25 @@ struct mt7996_sta {
 	struct mt7996_vow_sta_ctrl vow;
 };
 
-struct mt7996_vif {
+struct mt7996_bss_conf {
 	struct mt76_vif mt76; /* must be first */
 
-	struct mt7996_sta sta;
+	struct mt7996_vif *vif;
 	struct mt7996_phy *phy;
-
 	struct ieee80211_tx_queue_params queue_params[IEEE80211_NUM_ACS];
 	struct cfg80211_bitrate_mask bitrate_mask;
 
 	struct mt7996_chanctx *chanctx;
 };
 
+struct mt7996_vif {
+	struct mt7996_bss_conf deflink;
+	struct mt7996_bss_conf __rcu *link[IEEE80211_MLD_MAX_NUM_LINKS];
+
+	struct mt7996_sta sta;
+	struct mt7996_dev *dev;
+};
+
 /* crash-dump */
 struct mt7996_crash_data {
 	guid_t guid;
@@ -765,6 +772,13 @@ mt7996_chanctx_get(struct ieee80211_chanctx_conf *ctx)
 	return (struct mt7996_chanctx *)&ctx->drv_priv;
 }
 
+static inline struct mt7996_bss_conf *
+mconf_dereference_protected(struct mt7996_vif *mvif, u8 link_id)
+{
+	return rcu_dereference_protected(mvif->link[link_id],
+					 lockdep_is_held(&mvif->dev->mt76.mutex));
+}
+
 extern const struct ieee80211_ops mt7996_ops;
 extern struct pci_driver mt7996_pci_driver;
 extern struct pci_driver mt7996_hif_driver;
@@ -775,7 +789,7 @@ struct mt7996_dev *mt7996_mmio_probe(struct device *pdev,
 void mt7996_wfsys_reset(struct mt7996_dev *dev);
 void mt7996_rro_hw_init(struct mt7996_dev *dev);
 irqreturn_t mt7996_irq_handler(int irq, void *dev_instance);
-u64 __mt7996_get_tsf(struct ieee80211_hw *hw, struct mt7996_vif *mvif);
+u64 __mt7996_get_tsf(struct ieee80211_hw *hw, struct mt7996_bss_conf *mconf);
 int mt7996_register_device(struct mt7996_dev *dev);
 void mt7996_unregister_device(struct mt7996_dev *dev);
 const char *mt7996_eeprom_name(struct mt7996_dev *dev);
@@ -801,37 +815,47 @@ int mt7996_run(struct ieee80211_hw *hw);
 int mt7996_mcu_init(struct mt7996_dev *dev);
 int mt7996_mcu_init_firmware(struct mt7996_dev *dev);
 int mt7996_mcu_twt_agrt_update(struct mt7996_dev *dev,
-			       struct mt7996_vif *mvif,
+			       struct mt7996_bss_conf *mconf,
 			       struct mt7996_twt_flow *flow,
 			       int cmd);
 int mt7996_mcu_add_dev_info(struct mt7996_phy *phy,
-			    struct ieee80211_vif *vif, bool enable);
+			    struct ieee80211_bss_conf *conf,
+			    struct mt7996_bss_conf *mconf, bool enable);
 int mt7996_mcu_add_bss_info(struct mt7996_phy *phy,
-			    struct ieee80211_vif *vif, int enable);
-int mt7996_mcu_add_sta(struct mt7996_dev *dev, struct ieee80211_vif *vif,
-		       struct ieee80211_sta *sta, bool enable, bool newly);
+			    struct ieee80211_bss_conf *conf,
+			    struct mt7996_bss_conf *mconf, int enable);
+int mt7996_mcu_add_sta(struct mt7996_dev *dev, struct ieee80211_bss_conf *conf,
+		       struct mt7996_bss_conf *mconf, struct ieee80211_sta *sta,
+		       bool enable, bool newly);
 int mt7996_mcu_add_tx_ba(struct mt7996_dev *dev,
 			 struct ieee80211_ampdu_params *params,
 			 bool add);
 int mt7996_mcu_add_rx_ba(struct mt7996_dev *dev,
 			 struct ieee80211_ampdu_params *params,
 			 bool add);
-int mt7996_mcu_update_bss_color(struct mt7996_dev *dev, struct ieee80211_vif *vif,
+int mt7996_mcu_update_bss_color(struct mt7996_dev *dev,
+				struct mt7996_bss_conf *mconf,
 				struct cfg80211_he_bss_color *he_bss_color);
-int mt7996_mcu_add_beacon(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-			  int enable);
+int mt7996_mcu_add_beacon(struct ieee80211_hw *hw,
+			  struct ieee80211_bss_conf *conf,
+			  struct mt7996_bss_conf *mconf, int en);
 int mt7996_mcu_beacon_inband_discov(struct mt7996_dev *dev,
-				    struct ieee80211_vif *vif, u32 changed);
-int mt7996_mcu_add_obss_spr(struct mt7996_phy *phy, struct ieee80211_vif *vif,
+				    struct ieee80211_bss_conf *conf,
+				    struct mt7996_bss_conf *mconf, u32 changed);
+int mt7996_mcu_add_obss_spr(struct mt7996_phy *phy,
+			    struct mt7996_bss_conf *mconf,
 			    struct ieee80211_he_obss_pd *he_obss_pd);
-int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev, struct ieee80211_vif *vif,
+int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,
+			     struct ieee80211_bss_conf *conf,
+			     struct mt7996_bss_conf *mconf,
 			     struct ieee80211_sta *sta, bool changed);
 int mt7996_set_channel(struct mt7996_phy *phy, struct cfg80211_chan_def *chandef);
 int mt7996_mcu_set_chan_info(struct mt7996_phy *phy, u16 tag);
-int mt7996_mcu_set_tx(struct mt7996_dev *dev, struct ieee80211_vif *vif);
+int mt7996_mcu_set_tx(struct mt7996_dev *dev, struct mt7996_bss_conf *mconf);
 int mt7996_mcu_set_fixed_rate_ctrl(struct mt7996_dev *dev,
 				   void *data, u16 version);
-int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev, struct ieee80211_vif *vif,
+int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev,
+			       struct mt7996_bss_conf *mconf,
 			       struct ieee80211_sta *sta, void *data, u32 field);
 int mt7996_mcu_set_eeprom(struct mt7996_dev *dev);
 int mt7996_mcu_get_eeprom(struct mt7996_dev *dev, u32 offset, u8 *read_buf);
@@ -846,7 +870,7 @@ int mt7996_mcu_set_radar_th(struct mt7996_dev *dev, int index,
 			    const struct mt7996_dfs_pattern *pattern);
 int mt7996_mcu_set_radio_en(struct mt7996_phy *phy, bool enable);
 int mt7996_mcu_set_rts_thresh(struct mt7996_phy *phy, u32 val);
-int mt7996_mcu_set_timing(struct mt7996_phy *phy, struct ieee80211_vif *vif);
+int mt7996_mcu_set_timing(struct mt7996_phy *phy, struct mt7996_bss_conf *mconf);
 int mt7996_mcu_get_chan_mib_info(struct mt7996_phy *phy, bool chan_switch);
 int mt7996_mcu_get_temperature(struct mt7996_phy *phy);
 int mt7996_mcu_set_thermal_throttling(struct mt7996_phy *phy, u8 state);
@@ -885,8 +909,9 @@ void mt7996_tm_rf_test_event(struct mt7996_dev *dev, struct sk_buff *skb);
 int mt7996_mcu_set_scs(struct mt7996_phy *phy, u8 enable);
 void mt7996_mcu_scs_sta_poll(struct work_struct *work);
 int mt7996_mcu_set_band_confg(struct mt7996_phy *phy, u16 option, bool enable);
-int mt7996_mcu_set_vow_drr_ctrl(struct mt7996_phy *phy, struct mt7996_sta *msta,
-	                        enum vow_drr_ctrl_id id);
+int mt7996_mcu_set_vow_drr_ctrl(struct mt7996_phy *phy,
+				struct mt7996_bss_conf *mconf,
+				struct mt7996_sta *msta, enum vow_drr_ctrl_id id);
 int mt7996_mcu_set_vow_feature_ctrl(struct mt7996_phy *phy);
 void mt7996_mcu_wmm_pbc_work(struct work_struct *work);
 
@@ -995,13 +1020,16 @@ void mt7996_update_channel(struct mt76_phy *mphy);
 int mt7996_init_debugfs(struct mt7996_phy *phy);
 void mt7996_debugfs_rx_fw_monitor(struct mt7996_dev *dev, const void *data, int len);
 bool mt7996_debugfs_rx_log(struct mt7996_dev *dev, const void *data, int len);
-int mt7996_mcu_add_key(struct mt76_dev *dev, struct ieee80211_vif *vif,
+int mt7996_mcu_add_key(struct mt76_dev *dev, struct mt7996_bss_conf *mconf,
 		       struct ieee80211_key_conf *key, int mcu_cmd,
 		       struct mt76_wcid *wcid, enum set_key_cmd cmd);
-int mt7996_mcu_bcn_prot_enable(struct mt7996_dev *dev, struct ieee80211_vif *vif,
+int mt7996_mcu_bcn_prot_enable(struct mt7996_dev *dev,
+			       struct ieee80211_bss_conf *conf,
+			       struct mt7996_bss_conf *mconf,
 			       struct ieee80211_key_conf *key);
 int mt7996_mcu_wtbl_update_hdr_trans(struct mt7996_dev *dev,
 				     struct ieee80211_vif *vif,
+				     struct mt7996_bss_conf *mconf,
 				     struct ieee80211_sta *sta);
 int mt7996_mcu_cp_support(struct mt7996_dev *dev, u8 mode);
 int mt7996_mcu_set_pp_en(struct mt7996_phy *phy, bool auto_mode, u8 force_bitmap,
diff --git a/mt7996/mtk_debugfs_i.c b/mt7996/mtk_debugfs_i.c
new file mode 100644
index 000000000..21748e798
--- /dev/null
+++ b/mt7996/mtk_debugfs_i.c
@@ -0,0 +1,1639 @@
+#include <linux/inet.h>
+#include "mt7996.h"
+#include "../mt76.h"
+#include "mcu.h"
+#include "mac.h"
+#include "eeprom.h"
+#include "mtk_debug.h"
+#include "mtk_debug_i.h"
+#include "mtk_mcu.h"
+#include "mtk_mcu_i.h"
+
+#ifdef CONFIG_MTK_DEBUG
+
+#define info_or_seq_printf(seq, fmt, ...)	do {	\
+	if (seq)					\
+		seq_printf(seq, fmt, ##__VA_ARGS__);	\
+	else						\
+		pr_info(fmt, ##__VA_ARGS__);		\
+} while (0)
+
+static void info_or_seq_hex_dump(struct seq_file *seq, int prefix_type,
+				 int rowsize, int groupsize, const void *buf,
+				 size_t len, bool ascii)
+{
+	if (seq)
+		seq_hex_dump(seq, "", prefix_type, rowsize, groupsize,
+			     buf, len, ascii);
+	else
+		print_hex_dump(KERN_INFO, "", prefix_type,
+			       rowsize, groupsize, buf, len, ascii);
+}
+
+void mt7996_packet_log_to_host(struct mt7996_dev *dev, const void *data, int len, int type, int des_len)
+{
+	struct bin_debug_hdr *hdr;
+	char *buf;
+
+	if (len > 1500 - sizeof(*hdr))
+	len = 1500 - sizeof(*hdr);
+
+	buf = kzalloc(sizeof(*hdr) + len, GFP_KERNEL);
+	if (!buf)
+		return;
+
+	hdr = (struct bin_debug_hdr *)buf;
+	hdr->magic_num = cpu_to_le32(PKT_BIN_DEBUG_MAGIC);
+	hdr->serial_id = cpu_to_le16(dev->fw_debug_seq++);
+	hdr->msg_type = cpu_to_le16(type);
+	hdr->len = cpu_to_le16(len);
+	hdr->des_len = cpu_to_le16(des_len);
+
+	memcpy(buf + sizeof(*hdr), data, len);
+
+	mt7996_debugfs_rx_log(dev, buf, sizeof(*hdr) + len);
+	kfree(buf);
+}
+
+//bmac dump mac txp
+static void mt7996_dump_bmac_mac_txp_info(struct seq_file *s, struct mt7996_dev *dev,
+					  __le32 *txp)
+{
+	struct mt7996_txp_token {
+		__le16 msdu[4];
+	} *msdu;
+	struct mt7996_txp_ptr {
+		__le32 addr1;
+		__le32 addr_info;
+		__le32 addr2;
+	} *ptr;
+	int i = 0;
+
+	for (i = 0; i < 12; i = i+2 ) {
+		if (i == 0 || i == 4) {
+			msdu = (struct mt7996_txp_token *) txp;
+			info_or_seq_printf(s, "msdu token(%d-%d)=%ld %ld %ld %ld (0x%08x-0x%08x)\n", i, i+3,
+				(msdu->msdu[0] & GENMASK(14, 0)),
+				(msdu->msdu[1] & GENMASK(14, 0)),
+				(msdu->msdu[2] & GENMASK(14, 0)),
+				(msdu->msdu[3] & GENMASK(14, 0)), *txp, *(txp+1));
+			txp = txp + 2;
+		}
+		ptr = (struct mt7996_txp_ptr *) txp;
+		info_or_seq_printf(s, "ptr%02d : addr(0x%08x) len(%ld) addr_h(%02lx) SRC(%d) ML(%d) \n",
+			i, ptr->addr1,
+			FIELD_GET(GENMASK(11, 0), ptr->addr_info),
+			FIELD_GET(GENMASK(13, 12), ptr->addr_info),
+			!!(ptr->addr_info & BIT(14)),
+			!!(ptr->addr_info & BIT(15)));
+		info_or_seq_printf(s, "ptr%02d : addr(0x%08x) len(%ld) addr_h(%02lx) SRC(%d) ML(%d) \n",
+			i+1, ptr->addr2,
+			FIELD_GET(GENMASK(27, 16), ptr->addr_info),
+			FIELD_GET(GENMASK(29, 28), ptr->addr_info),
+			!!(ptr->addr_info & BIT(30)),
+			!!(ptr->addr_info & BIT(31)));
+		txp = txp + 3;
+	}
+}
+
+//bmac dump hif txp
+void mt7996_dump_bmac_hif_txp_info(struct seq_file *s, struct mt7996_dev *dev,
+				   __le32 *txp, u32 hif_txp_ver)
+{
+	int i, j = 0;
+	u32 dw;
+
+	info_or_seq_printf(s, "txp raw data: size=%d\n", HIF_TXP_V2_SIZE);
+	info_or_seq_hex_dump(s, DUMP_PREFIX_OFFSET, 16, 1, (u8 *)txp, HIF_TXP_V2_SIZE, false);
+
+	info_or_seq_printf(s, "BMAC_TXP Fields:\n");
+
+	/* dw0 */
+	if (hif_txp_ver == 2) {
+		dw = le32_to_cpu(txp[0]);
+		info_or_seq_printf(s, "HIF_TXP_PRIORITY = %d\n",
+				GET_FIELD(HIF_TXP_PRIORITY, dw));
+		info_or_seq_printf(s, "HIF_TXP_FIXED_RATE = %d\n",
+				GET_FIELD(HIF_TXP_FIXED_RATE, dw));
+		info_or_seq_printf(s, "HIF_TXP_TCP = %d\n",
+				GET_FIELD(HIF_TXP_TCP, dw));
+		info_or_seq_printf(s, "HIF_TXP_NON_CIPHER = %d\n",
+				GET_FIELD(HIF_TXP_NON_CIPHER, dw));
+		info_or_seq_printf(s, "HIF_TXP_VLAN = %d\n",
+				GET_FIELD(HIF_TXP_VLAN, dw));
+		info_or_seq_printf(s, "HIF_TXP_BC_MC_FLAG = %d\n",
+				GET_FIELD(HIF_TXP_BC_MC_FLAG, dw));
+		info_or_seq_printf(s, "HIF_TXP_FR_HOST = %d\n",
+				GET_FIELD(HIF_TXP_FR_HOST, dw));
+		info_or_seq_printf(s, "HIF_TXP_ETYPE = %d\n",
+				GET_FIELD(HIF_TXP_ETYPE, dw));
+		info_or_seq_printf(s, "HIF_TXP_TXP_AMSDU = %d\n",
+				GET_FIELD(HIF_TXP_TXP_AMSDU, dw));
+		info_or_seq_printf(s, "HIF_TXP_TXP_MC_CLONE = %d\n",
+				GET_FIELD(HIF_TXP_TXP_MC_CLONE, dw));
+		info_or_seq_printf(s, "HIF_TXP_TOKEN_ID = %d\n",
+				GET_FIELD(HIF_TXP_TOKEN_ID, dw));
+
+		/* dw1 */
+		dw = le32_to_cpu(txp[1]);
+		info_or_seq_printf(s, "HIF_TXP_BSS_IDX = %d\n",
+				GET_FIELD(HIF_TXP_BSS_IDX, dw));
+		info_or_seq_printf(s, "HIF_TXP_USER_PRIORITY = %d\n",
+				GET_FIELD(HIF_TXP_USER_PRIORITY, dw));
+		info_or_seq_printf(s, "HIF_TXP_BUF_NUM = %d\n",
+				GET_FIELD(HIF_TXP_BUF_NUM, dw));
+		info_or_seq_printf(s, "HIF_TXP_MSDU_CNT = %d\n",
+				GET_FIELD(HIF_TXP_MSDU_CNT, dw));
+		info_or_seq_printf(s, "HIF_TXP_SRC = %d\n",
+				GET_FIELD(HIF_TXP_SRC, dw));
+
+		/* dw2 */
+		dw = le32_to_cpu(txp[2]);
+		info_or_seq_printf(s, "HIF_TXP_ETH_TYPE(network-endian) = 0x%x\n",
+				GET_FIELD(HIF_TXP_ETH_TYPE, dw));
+		info_or_seq_printf(s, "HIF_TXP_WLAN_IDX = %d\n",
+				GET_FIELD(HIF_TXP_WLAN_IDX, dw));
+
+		/* dw3 */
+		dw = le32_to_cpu(txp[3]);
+		info_or_seq_printf(s, "HIF_TXP_PPE_INFO = 0x%x\n",
+				GET_FIELD(HIF_TXP_PPE_INFO, dw));
+
+		for (i = 0; i < 13; i++) {
+			if (i % 2 == 0) {
+				info_or_seq_printf(s, "HIF_TXP_BUF_PTR%d_L = 0x%x\n",
+						i, GET_FIELD(HIF_TXP_BUF_PTR0_L,
+						le32_to_cpu(txp[4 + j])));
+				j++;
+				info_or_seq_printf(s, "HIF_TXP_BUF_LEN%d = %d\n",
+						i, GET_FIELD(HIF_TXP_BUF_LEN0, le32_to_cpu(txp[4 + j])));
+				info_or_seq_printf(s, "HIF_TXP_BUF_PTR%d_H = 0x%x\n",
+						i, GET_FIELD(HIF_TXP_BUF_PTR0_H, le32_to_cpu(txp[4 + j])));
+				if (i <= 10) {
+					info_or_seq_printf(s, "HIF_TXP_BUF_LEN%d = %d\n",
+							i + 1, GET_FIELD(HIF_TXP_BUF_LEN1, le32_to_cpu(txp[4 + j])));
+					info_or_seq_printf(s, "HIF_TXP_BUF_PTR%d_H = 0x%x\n",
+							i + 1, GET_FIELD(HIF_TXP_BUF_PTR1_H, le32_to_cpu(txp[4 + j])));
+				}
+				j++;
+			} else {
+				info_or_seq_printf(s, "HIF_TXP_BUF_PTR%d_L = 0x%x\n",
+					i, GET_FIELD(HIF_TXP_BUF_PTR1_L,
+					le32_to_cpu(txp[4 + j])));
+				j++;
+			}
+		}
+
+		info_or_seq_printf(s, "ml = 0x%x\n",
+			GET_FIELD(HIF_TXP_ML, le32_to_cpu(txp[23])));
+	} else {
+		struct mt76_connac_txp_common *txp_v1 = (struct mt76_connac_txp_common *)txp;
+
+		info_or_seq_printf(s, "FLAGS = (%04x)\n", txp_v1->fw.flags);
+
+		info_or_seq_printf(s, "MSDU = %d\n", txp_v1->fw.token);
+
+		info_or_seq_printf(s, "BSS_IDX = %d\n", txp_v1->fw.bss_idx);
+
+		info_or_seq_printf(s, "WCID = %d\n",txp_v1->fw.rept_wds_wcid);
+
+		info_or_seq_printf(s, "MSDU_CNT = %d\n", txp_v1->fw.nbuf);
+
+		for (i = 0; i < MT_TXP_MAX_BUF_NUM; i++)
+			info_or_seq_printf(s, "ptr%02d : addr(0x%08x) len(%d)\n", i, le32_to_cpu(txp_v1->fw.buf[i]),
+				le16_to_cpu(txp_v1->fw.len[i]));
+	}
+}
+
+/* bmac txd dump */
+void mt7996_dump_bmac_txd_info(struct seq_file *s, struct mt7996_dev *dev,
+			       __le32 *txd, bool is_hif_txd, bool dump_txp)
+{
+	u32 hif_txp_ver = 0;
+
+	/* dump stop */
+	if (!dev->dbg.txd_read_cnt)
+		return;
+
+	/* force dump */
+	if (dev->dbg.txd_read_cnt > 8)
+		dev->dbg.txd_read_cnt = 8;
+
+	/* dump txd_read_cnt times */
+	if (dev->dbg.txd_read_cnt != 8)
+		dev->dbg.txd_read_cnt--;
+
+	info_or_seq_printf(s, "txd raw data: size=%d\n", MT_TXD_SIZE);
+	info_or_seq_hex_dump(s, DUMP_PREFIX_OFFSET, 16, 1, (u8 *)txd, MT_TXD_SIZE, false);
+
+	info_or_seq_printf(s, "BMAC_TXD Fields:\n");
+	/* dw0 */
+	if (is_hif_txd) {
+		hif_txp_ver = FIELD_GET(GENMASK(22, 19), txd[0]);
+		info_or_seq_printf(s, "HIF TXD VER = %d\n", hif_txp_ver);
+	}
+	info_or_seq_printf(s, "TX_BYTE_COUNT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TX_BYTE_COUNT, txd[0]));
+	info_or_seq_printf(s, "ETHER_TYPE_OFFSET(word) = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_ETHER_TYPE_OFFSET, txd[0]));
+	info_or_seq_printf(s, "PKT_FT = %d%s%s%s%s\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PKT_FT, txd[0]),
+			GET_FIELD(WF_TX_DESCRIPTOR_PKT_FT, txd[0]) == 0 ? "(ct)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_PKT_FT, txd[0]) == 1 ? "(s&f)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_PKT_FT, txd[0]) == 2 ? "(cmd)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_PKT_FT, txd[0]) == 3 ? "(redirect)" : "");
+	info_or_seq_printf(s, "Q_IDX = %d%s%s%s\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_Q_IDX, txd[0]),
+			GET_FIELD(WF_TX_DESCRIPTOR_Q_IDX, txd[0]) == 0x10 ? "(ALTX)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_Q_IDX, txd[0]) == 0x11 ? "(BMC)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_Q_IDX, txd[0]) == 0x12 ? "(BCN)" : "");
+
+	/* dw1 */
+	info_or_seq_printf(s, "MLD_ID = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_MLD_ID, txd[1]));
+	info_or_seq_printf(s, "TGID = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TGID, txd[1]));
+	info_or_seq_printf(s, "HF = %d%s%s%s%s\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]),
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ? "(eth/802.3)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 1 ? "(cmd)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 2 ? "(802.11)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 3 ? "(802.11 enhanced" : "");
+	info_or_seq_printf(s, "802.11 HEADER_LENGTH = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 2 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_HEADER_LENGTH, txd[1]) : 0);
+	info_or_seq_printf(s, "MRD = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_MRD, txd[1]) : 0);
+	info_or_seq_printf(s, "EOSP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_EOSP, txd[1]) : 0);
+	info_or_seq_printf(s, "AMS = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 3 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_AMS, txd[1]) : 0);
+	info_or_seq_printf(s, "RMVL = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_RMVL, txd[1]): 0);
+	info_or_seq_printf(s, "VLAN = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_VLAN, txd[1]) : 0);
+	info_or_seq_printf(s, "ETYP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_ETYP, txd[1]) : 0);
+	info_or_seq_printf(s, "TID_MGMT_TYPE = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TID_MGMT_TYPE, txd[1]));
+	info_or_seq_printf(s, "OM = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_OM, txd[1]));
+	info_or_seq_printf(s, "FR = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FR, txd[1]));
+
+	/* dw2 */
+	info_or_seq_printf(s, "SUBTYPE = %d%s%s%s%s\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_SUBTYPE, txd[2]),
+			(GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 0) &&
+			(GET_FIELD(WF_TX_DESCRIPTOR_SUBTYPE, txd[2]) == 13) ?
+			"(action)" : "",
+			(GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 1) &&
+			(GET_FIELD(WF_TX_DESCRIPTOR_SUBTYPE, txd[2]) == 8) ?
+			"(bar)" : "",
+			(GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 2) &&
+			(GET_FIELD(WF_TX_DESCRIPTOR_SUBTYPE, txd[2]) == 4) ?
+			"(null)" : "",
+			(GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 2) &&
+			(GET_FIELD(WF_TX_DESCRIPTOR_SUBTYPE, txd[2]) == 12) ?
+			"(qos null)" : "");
+
+	info_or_seq_printf(s, "FTYPE = %d%s%s%s\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]),
+			GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 0 ? "(mgmt)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 1 ? "(ctl)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 2 ? "(data)" : "");
+	info_or_seq_printf(s, "BF_TYPE = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_BF_TYPE, txd[2]));
+	info_or_seq_printf(s, "OM_MAP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_OM_MAP, txd[2]));
+	info_or_seq_printf(s, "RTS = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_RTS, txd[2]));
+	info_or_seq_printf(s, "HEADER_PADDING = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HEADER_PADDING, txd[2]));
+	info_or_seq_printf(s, "DU = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_DU, txd[2]));
+	info_or_seq_printf(s, "HE = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HE, txd[2]));
+	info_or_seq_printf(s, "FRAG = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FRAG, txd[2]));
+	info_or_seq_printf(s, "REMAINING_TX_TIME = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_REMAINING_TX_TIME, txd[2]));
+	info_or_seq_printf(s, "POWER_OFFSET = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_POWER_OFFSET, txd[2]));
+
+	/* dw3 */
+	info_or_seq_printf(s, "NA = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_NA, txd[3]));
+	info_or_seq_printf(s, "PF = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PF, txd[3]));
+	info_or_seq_printf(s, "EMRD = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_EMRD, txd[3]));
+	info_or_seq_printf(s, "EEOSP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_EEOSP, txd[3]));
+	info_or_seq_printf(s, "BM = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_BM, txd[3]));
+	info_or_seq_printf(s, "HW_AMSDU_CAP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HW_AMSDU_CAP, txd[3]));
+	info_or_seq_printf(s, "TX_COUNT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TX_COUNT, txd[3]));
+	info_or_seq_printf(s, "REMAINING_TX_COUNT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_REMAINING_TX_COUNT, txd[3]));
+	info_or_seq_printf(s, "SN = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_SN, txd[3]));
+	info_or_seq_printf(s, "BA_DIS = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_BA_DIS, txd[3]));
+	info_or_seq_printf(s, "PM = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PM, txd[3]));
+	info_or_seq_printf(s, "PN_VLD = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PN_VLD, txd[3]));
+	info_or_seq_printf(s, "SN_VLD = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_SN_VLD, txd[3]));
+
+	/* dw4 */
+	info_or_seq_printf(s, "PN_31_0 = 0x%x\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PN_31_0_, txd[4]));
+
+	/* dw5 */
+	info_or_seq_printf(s, "PID = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PID, txd[5]));
+	info_or_seq_printf(s, "TXSFM = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TXSFM, txd[5]));
+	info_or_seq_printf(s, "TXS2M = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TXS2M, txd[5]));
+	info_or_seq_printf(s, "TXS2H = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TXS2H, txd[5]));
+	info_or_seq_printf(s, "FBCZ = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FBCZ, txd[5]));
+	info_or_seq_printf(s, "BYPASS_RBB = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_BYPASS_RBB, txd[5]));
+
+	info_or_seq_printf(s, "FL = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FL, txd[5]));
+	info_or_seq_printf(s, "PN_47_32 = 0x%x\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PN_47_32_, txd[5]));
+
+	/* dw6 */
+	info_or_seq_printf(s, "AMSDU_CAP_UTXB = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_AMSDU_CAP_UTXB, txd[6]));
+	info_or_seq_printf(s, "DAS = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_DAS, txd[6]));
+	info_or_seq_printf(s, "DIS_MAT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_DIS_MAT, txd[6]));
+	info_or_seq_printf(s, "MSDU_COUNT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_MSDU_COUNT, txd[6]));
+	info_or_seq_printf(s, "TIMESTAMP_OFFSET = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_IDX, txd[6]));
+	info_or_seq_printf(s, "FIXED_RATE_IDX = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FIXED_RATE_IDX, txd[6]));
+	info_or_seq_printf(s, "BW = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_BW, txd[6]));
+	info_or_seq_printf(s, "VTA = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_VTA, txd[6]));
+	info_or_seq_printf(s, "SRC = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_SRC, txd[6]));
+
+	/* dw7 */
+	info_or_seq_printf(s, "SW_TX_TIME(unit:65536ns) = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_SW_TX_TIME , txd[7]));
+	info_or_seq_printf(s, "UT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_UT, txd[7]));
+	info_or_seq_printf(s, "CTXD_CNT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_CTXD_CNT, txd[7]));
+	info_or_seq_printf(s, "HM = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HM, txd[7]));
+	info_or_seq_printf(s, "DP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_DP, txd[7]));
+	info_or_seq_printf(s, "IP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_IP, txd[7]));
+	info_or_seq_printf(s, "TXD_LEN = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TXD_LEN, txd[7]));
+
+	if (dump_txp) {
+		__le32 *txp = txd + 8;
+
+		if (is_hif_txd)
+			mt7996_dump_bmac_hif_txp_info(s, dev, txp, hif_txp_ver);
+		else
+			mt7996_dump_bmac_mac_txp_info(s, dev, txp);
+	}
+}
+
+static void
+mt7996_dump_mac_fid(struct seq_file *s, struct mt7996_dev *dev, u32 fid, bool is_ple)
+{
+#define PLE_MEM_SIZE	 128
+#define PSE_MEM_SIZE	 256
+	 u8 data[PSE_MEM_SIZE] = {0};
+	 u32 addr = 0;
+	 int i = 0, cr_cnt = PSE_MEM_SIZE;
+	 u32 *ptr = (u32 *) data;
+
+	 if (is_ple) {
+		cr_cnt = PLE_MEM_SIZE;
+		seq_printf(s, "dump ple: fid = 0x%08x\n", fid);
+	 } else {
+		seq_printf(s, "dump pse: fid = 0x%08x\n", fid);
+	 }
+
+	 for (i = 0; i < cr_cnt; i = i + 4) {
+		if (is_ple)
+			addr = (0xa << 28 | fid << 15) + i;
+		else
+			addr = (0xb << 28 | fid << 15) + i;
+		*ptr = mt76_rr(dev, addr);
+		ptr++;
+	 }
+
+	 seq_printf(s, "raw data: size=%d\n", cr_cnt);
+
+	 seq_hex_dump(s, "", DUMP_PREFIX_OFFSET, 16, 1, (u8 *)data, cr_cnt, false);
+	 /* dump one txd info */
+	 if (is_ple) {
+		 dev->dbg.txd_read_cnt = 1;
+		 mt7996_dump_bmac_txd_info(s, dev, (__le32 *)&data[0], false, true);
+	 }
+}
+
+static int
+mt7996_ple_fid_read(struct seq_file *s, void *data) {
+	 struct mt7996_dev *dev = dev_get_drvdata(s->private);
+
+	 mt7996_dump_mac_fid(s, dev, dev->dbg.fid_idx, true);
+	 return 0;
+}
+
+static int
+mt7996_pse_fid_read(struct seq_file *s, void *data) {
+	 struct mt7996_dev *dev = dev_get_drvdata(s->private);
+
+	 mt7996_dump_mac_fid(s, dev, dev->dbg.fid_idx, false);
+	 return 0;
+}
+
+void mt7996_dump_bmac_rxd_info(struct mt7996_dev *dev, __le32 *rxd)
+{
+	/* dump stop */
+	if (!dev->dbg.rxd_read_cnt)
+		return;
+
+	/* force dump */
+	if (dev->dbg.rxd_read_cnt > 8)
+		dev->dbg.rxd_read_cnt = 8;
+
+	/* dump txd_read_cnt times */
+	if (dev->dbg.rxd_read_cnt != 8)
+		dev->dbg.rxd_read_cnt--;
+
+	printk("rxd raw data: size=%d\n", MT_TXD_SIZE);
+	print_hex_dump(KERN_ERR , "", DUMP_PREFIX_OFFSET, 16, 1, (u8 *)rxd, 96, false);
+
+	printk("BMAC_RXD Fields:\n");
+
+	/* group0 */
+	/* dw0 */
+	printk("RX_BYTE_COUNT = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_RX_BYTE_COUNT, le32_to_cpu(rxd[0])));
+	printk("PACKET_TYPE = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_PACKET_TYPE, le32_to_cpu(rxd[0])));
+
+	/* dw1 */
+	printk("MLD_ID = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_MLD_ID, le32_to_cpu(rxd[1])));
+	printk("GROUP_VLD = 0x%x%s%s%s%s%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1])),
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_1 ? "[group1]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_2 ? "[group2]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_3 ? "[group3]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ? "[group4]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_5 ? "[group5]" : "");
+	printk("KID = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_KID, le32_to_cpu(rxd[1])));
+	printk("CM = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_CM, le32_to_cpu(rxd[1])));
+	printk("CLM = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_CLM, le32_to_cpu(rxd[1])));
+	printk("I = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_I, le32_to_cpu(rxd[1])));
+	printk("T = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_T, le32_to_cpu(rxd[1])));
+	printk("BN = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BN, le32_to_cpu(rxd[1])));
+	printk("BIPN_FAIL = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BIPN_FAIL, le32_to_cpu(rxd[1])));
+
+	/* dw2 */
+	printk("BSSID = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BSSID, le32_to_cpu(rxd[2])));
+	printk("H = %d%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_H, le32_to_cpu(rxd[2])),
+			GET_FIELD(WF_RX_DESCRIPTOR_H, le32_to_cpu(rxd[2])) == 0 ?
+			"802.11 frame" : "eth/802.3 frame");
+	printk("HEADER_LENGTH(word) = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_HEADER_LENGTH, le32_to_cpu(rxd[2])));
+	printk("HO(word) = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_HO, le32_to_cpu(rxd[2])));
+	printk("SEC_MODE = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_SEC_MODE, le32_to_cpu(rxd[2])));
+	printk("MUBAR = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_MUBAR, le32_to_cpu(rxd[2])));
+	printk("SWBIT = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_SWBIT, le32_to_cpu(rxd[2])));
+	printk("DAF = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_DAF, le32_to_cpu(rxd[2])));
+	printk("EL = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_EL, le32_to_cpu(rxd[2])));
+	printk("HTF = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_HTF, le32_to_cpu(rxd[2])));
+	printk("INTF = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_INTF, le32_to_cpu(rxd[2])));
+	printk("FRAG = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_FRAG, le32_to_cpu(rxd[2])));
+	printk("NUL = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_NUL, le32_to_cpu(rxd[2])));
+	printk("NDATA = %d%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_NDATA, le32_to_cpu(rxd[2])),
+			GET_FIELD(WF_RX_DESCRIPTOR_NDATA, le32_to_cpu(rxd[2])) == 0 ?
+			"[data frame]" : "[mgmt/ctl frame]");
+	printk("NAMP = %d%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_NAMP, le32_to_cpu(rxd[2])),
+			GET_FIELD(WF_RX_DESCRIPTOR_NAMP, le32_to_cpu(rxd[2])) == 0 ?
+			"[ampdu frame]" : "[mpdu frame]");
+	printk("BF_RPT = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BF_RPT, le32_to_cpu(rxd[2])));
+
+	/* dw3 */
+	printk("RXV_SN = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_RXV_SN, le32_to_cpu(rxd[3])));
+	printk("CH_FREQUENCY = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_CH_FREQUENCY, le32_to_cpu(rxd[3])));
+	printk("A1_TYPE = %d%s%s%s%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_A1_TYPE, le32_to_cpu(rxd[3])),
+			GET_FIELD(WF_RX_DESCRIPTOR_A1_TYPE, le32_to_cpu(rxd[3])) == 0 ?
+			"[reserved]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_A1_TYPE, le32_to_cpu(rxd[3])) == 1 ?
+			"[uc2me]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_A1_TYPE, le32_to_cpu(rxd[3])) == 2 ?
+			"[mc]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_A1_TYPE, le32_to_cpu(rxd[3])) == 3 ?
+			"[bc]" : "");
+	printk("HTC = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_HTC, le32_to_cpu(rxd[3])));
+	printk("TCL = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_TCL, le32_to_cpu(rxd[3])));
+	printk("BBM = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BBM, le32_to_cpu(rxd[3])));
+	printk("BU = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BU, le32_to_cpu(rxd[3])));
+	printk("CO_ANT = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_CO_ANT, le32_to_cpu(rxd[3])));
+	printk("BF_CQI = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BF_CQI, le32_to_cpu(rxd[3])));
+	printk("FC = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_FC, le32_to_cpu(rxd[3])));
+	printk("VLAN = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_VLAN, le32_to_cpu(rxd[3])));
+
+	/* dw4 */
+	printk("PF = %d%s%s%s%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_PF, le32_to_cpu(rxd[4])),
+			GET_FIELD(WF_RX_DESCRIPTOR_PF, le32_to_cpu(rxd[4])) == 0 ?
+			"[msdu]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_PF, le32_to_cpu(rxd[4])) == 1 ?
+			"[final amsdu]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_PF, le32_to_cpu(rxd[4])) == 2 ?
+			"[middle amsdu]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_PF, le32_to_cpu(rxd[4])) == 3 ?
+			"[first amsdu]" : "");
+	printk("MAC = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_MAC, le32_to_cpu(rxd[4])));
+	printk("TID = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_TID, le32_to_cpu(rxd[4])));
+	printk("ETHER_TYPE_OFFSET = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_ETHER_TYPE_OFFSET, le32_to_cpu(rxd[4])));
+	printk("IP = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_IP, le32_to_cpu(rxd[4])));
+	printk("UT = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_UT, le32_to_cpu(rxd[4])));
+	printk("PSE_FID = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_PSE_FID, le32_to_cpu(rxd[4])));
+
+	/* group4 */
+	/* dw0 */
+	printk("FRAME_CONTROL_FIELD = 0x%x\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_FRAME_CONTROL_FIELD, le32_to_cpu(rxd[8])) : 0);
+	printk("PEER_MLD_ADDRESS_15_0 = 0x%x\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_15_0_,
+			le32_to_cpu(rxd[8])) : 0);
+
+	/* dw1 */
+	printk("PEER_MLD_ADDRESS_47_16 = 0x%x\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_47_16_,
+			le32_to_cpu(rxd[9])) : 0);
+
+	/* dw2 */
+	printk("FRAGMENT_NUMBER = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_FRAGMENT_NUMBER,
+			le32_to_cpu(rxd[10])) : 0);
+	printk("SEQUENCE_NUMBER = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_SEQUENCE_NUMBER,
+			le32_to_cpu(rxd[10])) : 0);
+	printk("QOS_CONTROL_FIELD = 0x%x\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_QOS_CONTROL_FIELD,
+			le32_to_cpu(rxd[10])) : 0);
+
+	/* dw3 */
+	printk("HT_CONTROL_FIELD = 0x%x\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_HT_CONTROL_FIELD,
+			le32_to_cpu(rxd[11])) : 0);
+}
+
+static int mt7996_token_txd_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct mt76_txwi_cache *t;
+	u8* txwi;
+
+	seq_printf(s, "\n");
+	spin_lock_bh(&dev->mt76.token_lock);
+
+	t = idr_find(&dev->mt76.token, dev->dbg.token_idx);
+	if (t != NULL) {
+		struct mt76_dev *mdev = &dev->mt76;
+		txwi = ((u8*)(t)) - (mdev->drv->txwi_size);
+		/* dump one txd info */
+		dev->dbg.txd_read_cnt = 1;
+		mt7996_dump_bmac_txd_info(s, dev, (__le32 *)txwi, true, true);
+		seq_printf(s, "\n");
+		seq_printf(s, "[SKB]\n");
+		seq_hex_dump(s, "", DUMP_PREFIX_OFFSET, 16, 1, (u8 *)t->skb->data, t->skb->len, false);
+		seq_printf(s, "\n");
+	}
+	spin_unlock_bh(&dev->mt76.token_lock);
+	return 0;
+}
+
+static int mt7996_rx_token_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	int id, count = 0;
+	struct mt76_rxwi_cache *r;
+
+	seq_printf(s, "Rx cut through token:\n");
+	spin_lock_bh(&dev->mt76.rx_token_lock);
+	idr_for_each_entry(&dev->mt76.rx_token, r, id) {
+		count++;
+	}
+	seq_printf(s, "\ttotal:%8d used:%8d\n",
+		   dev->mt76.rx_token_size, count);
+	spin_unlock_bh(&dev->mt76.rx_token_lock);
+
+	return 0;
+}
+
+static int mt7996_rx_msdu_pg_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct list_head *p;
+	int i, count = 0, total = 0;
+
+	seq_printf(s, "Rx Msdu page:\n");
+	spin_lock(&dev->wed_rro.lock);
+	for (i = 0; i < MT7996_RRO_MSDU_PG_HASH_SIZE; i++) {
+		list_for_each(p, &dev->wed_rro.pg_hash_head[i]) {
+			count++;
+		}
+	}
+
+	total = count;
+	list_for_each(p, &dev->wed_rro.pg_addr_cache) {
+		total++;
+	}
+	seq_printf(s, "\ttotal:%8d used:%8d\n", total, count);
+	spin_unlock(&dev->wed_rro.lock);
+
+	return 0;
+}
+
+/* AMSDU SETTING */
+static ssize_t mt7996_amsdu_algo_write(struct file *file,
+				   const char __user *user_buf,
+				   size_t count,
+				   loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	char buf[100];
+	int ret;
+	struct {
+		u8 _rsv[4];
+
+		u16 tag;
+		u16 len;
+
+		u16 wlan_idx;
+		u8 algo_en;
+		u8 rsv[1];
+	} __packed data = {
+		.tag = cpu_to_le16(UNI_MEC_AMSDU_ALGO_EN_STA),
+		.len = cpu_to_le16(sizeof(data) - 4),
+	};
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+	if (sscanf(buf, "%hu %hhu", &data.wlan_idx, &data.algo_en) != 2)
+		return -EINVAL;
+
+	if (data.wlan_idx >= mt7996_wtbl_size(dev))
+		return -EINVAL;
+
+	ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MEC), &data,
+				sizeof(data), true);
+	if (ret)
+		return -EINVAL;
+
+	return count;
+}
+static const struct file_operations fops_amsdu_algo = {
+	.write = mt7996_amsdu_algo_write,
+	.read = NULL,
+	.open = simple_open,
+	.llseek = default_llseek,
+};
+
+static ssize_t mt7996_amsdu_para_write(struct file *file,
+				   const char __user *user_buf,
+				   size_t count,
+				   loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	char buf[100];
+	int ret;
+	struct {
+		u8 _rsv[4];
+
+		u16 tag;
+		u16 len;
+
+		u16 wlan_idx;
+		u8  amsdu_en;
+		u8  num;
+		u16 lenth;
+		u8  rsv[2];
+	} __packed data = {
+		.tag = cpu_to_le16(UNI_MEC_AMSDU_PARA_STA),
+		.len = cpu_to_le16(sizeof(data) - 4),
+	};
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+	if (sscanf(buf, "%hu %hhu %hhu %hu", &data.wlan_idx, &data.amsdu_en, &data.num, &data.lenth) != 4)
+		return -EINVAL;
+
+	if (data.wlan_idx >= mt7996_wtbl_size(dev))
+		return -EINVAL;
+
+	ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MEC), &data,
+			  sizeof(data), true);
+	if (ret)
+		return -EINVAL;
+
+	return count;
+}
+static const struct file_operations fops_amsdu_para = {
+	.write = mt7996_amsdu_para_write,
+	.read = NULL,
+	.open = simple_open,
+	.llseek = default_llseek,
+};
+
+static int mt7996_amsdu_info_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	u32 amsdu_cnt[WF_PLE_TOP_AMSDU_PACK_NUM] = {0}, total_cnt;
+	u8 i;
+
+	seq_printf(s, "HW A-MSDU Information:\n");
+
+	for (total_cnt = 0, i = 0; i < WF_PLE_TOP_AMSDU_PACK_NUM; ++i) {
+		amsdu_cnt[i] = mt76_rr(dev, WF_PLE_TOP_AMSDU_PACK_1_MSDU_CNT_ADDR + i * 4);
+		total_cnt += amsdu_cnt[i];
+	}
+
+	for (i = 0; i < WF_PLE_TOP_AMSDU_PACK_NUM; ++i) {
+		seq_printf(s, "# of HW A-MSDU containing %hhu MSDU: 0x%x",
+		           i + 1, amsdu_cnt[i]);
+		seq_printf(s, "\t(%u.%u%%)\n",
+		           total_cnt ? amsdu_cnt[i] * 1000 / total_cnt / 10 : 0,
+		           total_cnt ? amsdu_cnt[i] * 1000 / total_cnt % 10 : 0);
+	}
+
+	return 0;
+}
+
+/* PSE INFO */
+static struct bmac_queue_info_t pse_queue_empty_info[] = {
+	{"CPU Q0",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_0},
+	{"CPU Q1",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_1},
+	{"CPU Q2",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_2},
+	{"CPU Q3",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_3},
+	{NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, /* 4~7 not defined */
+	{NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	{NULL, 0, 0}, {NULL, 0, 0},  /* 14~15 not defined */
+	{"LMAC Q",  ENUM_UMAC_LMAC_PORT_2,    0},
+	{"MDP TX Q0", ENUM_UMAC_LMAC_PORT_2, 1},
+	{"MDP RX Q", ENUM_UMAC_LMAC_PORT_2, 2},
+	{"SEC TX Q0", ENUM_UMAC_LMAC_PORT_2, 3},
+	{"SEC RX Q", ENUM_UMAC_LMAC_PORT_2, 4},
+	{"SFD_PARK Q", ENUM_UMAC_LMAC_PORT_2, 5},
+	{"MDP_TXIOC Q0", ENUM_UMAC_LMAC_PORT_2, 6},
+	{"MDP_RXIOC Q0", ENUM_UMAC_LMAC_PORT_2, 7},
+	{"MDP TX Q1", ENUM_UMAC_LMAC_PORT_2, 0x11},
+	{"SEC TX Q1", ENUM_UMAC_LMAC_PORT_2, 0x13},
+	{"MDP_TXIOC Q1", ENUM_UMAC_LMAC_PORT_2, 0x16},
+	{"MDP_RXIOC Q1", ENUM_UMAC_LMAC_PORT_2, 0x17},
+	{"CPU Q3",  ENUM_UMAC_CPU_PORT_1,     4},
+	{NULL, 0, 0}, {NULL, 0, 0},
+	{"RLS Q",  ENUM_PLE_CTRL_PSE_PORT_3, ENUM_UMAC_PLE_CTRL_P3_Q_0X1F}
+};
+
+static struct bmac_queue_info_t pse_queue_empty2_info[] = {
+	{"MDP_TDPIOC Q0", ENUM_UMAC_LMAC_PORT_2, 0x8},
+	{"MDP_RDPIOC Q0", ENUM_UMAC_LMAC_PORT_2, 0x9},
+	{"MDP_TDPIOC Q1", ENUM_UMAC_LMAC_PORT_2, 0x18},
+	{"MDP_RDPIOC Q1", ENUM_UMAC_LMAC_PORT_2, 0x19},
+	{"MDP_TDPIOC Q2", ENUM_UMAC_LMAC_PORT_2, 0x28},
+	{"MDP_RDPIOC Q2", ENUM_UMAC_LMAC_PORT_2, 0x29},
+	{NULL, 0, 0},
+	{"MDP_RDPIOC Q3", ENUM_UMAC_LMAC_PORT_2, 0x39},
+	{"MDP TX Q2", ENUM_UMAC_LMAC_PORT_2, 0x21},
+	{"SEC TX Q2", ENUM_UMAC_LMAC_PORT_2, 0x23},
+	{"MDP_TXIOC Q2", ENUM_UMAC_LMAC_PORT_2, 0x26},
+	{"MDP_RXIOC Q2", ENUM_UMAC_LMAC_PORT_2, 0x27},
+	{NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	{"MDP_RXIOC Q3", ENUM_UMAC_LMAC_PORT_2, 0x37},
+	{"HIF Q0", ENUM_UMAC_HIF_PORT_0,    0},
+	{"HIF Q1", ENUM_UMAC_HIF_PORT_0,    1},
+	{"HIF Q2", ENUM_UMAC_HIF_PORT_0,    2},
+	{"HIF Q3", ENUM_UMAC_HIF_PORT_0,    3},
+	{"HIF Q4", ENUM_UMAC_HIF_PORT_0,    4},
+	{"HIF Q5", ENUM_UMAC_HIF_PORT_0,    5},
+	{"HIF Q6", ENUM_UMAC_HIF_PORT_0,    6},
+	{"HIF Q7", ENUM_UMAC_HIF_PORT_0,    7},
+	{"HIF Q8", ENUM_UMAC_HIF_PORT_0,    8},
+	{"HIF Q9", ENUM_UMAC_HIF_PORT_0,    9},
+	{"HIF Q10", ENUM_UMAC_HIF_PORT_0,    10},
+	{"HIF Q11", ENUM_UMAC_HIF_PORT_0,    11},
+	{"HIF Q12", ENUM_UMAC_HIF_PORT_0,    12},
+	{"HIF Q13", ENUM_UMAC_HIF_PORT_0,    13},
+	{NULL, 0, 0}, {NULL, 0, 0}
+};
+
+static int
+mt7996_pseinfo_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	u32 pse_buf_ctrl, pg_sz, pg_num;
+	u32 pse_stat[2], pg_flow_ctrl[28] = {0};
+	u32 fpg_cnt, ffa_cnt, fpg_head, fpg_tail;
+	u32 max_q, min_q, rsv_pg, used_pg;
+	int i;
+
+	pse_buf_ctrl = mt76_rr(dev, WF_PSE_TOP_PBUF_CTRL_ADDR);
+	pse_stat[0] = mt76_rr(dev, WF_PSE_TOP_QUEUE_EMPTY_ADDR);
+	pse_stat[1] = mt76_rr(dev, WF_PSE_TOP_QUEUE_EMPTY_1_ADDR);
+	pg_flow_ctrl[0] = mt76_rr(dev, WF_PSE_TOP_FREEPG_CNT_ADDR);
+	pg_flow_ctrl[1] = mt76_rr(dev, WF_PSE_TOP_FREEPG_HEAD_TAIL_ADDR);
+	pg_flow_ctrl[2] = mt76_rr(dev, WF_PSE_TOP_PG_HIF0_GROUP_ADDR);
+	pg_flow_ctrl[3] = mt76_rr(dev, WF_PSE_TOP_HIF0_PG_INFO_ADDR);
+	pg_flow_ctrl[4] = mt76_rr(dev, WF_PSE_TOP_PG_HIF1_GROUP_ADDR);
+	pg_flow_ctrl[5] = mt76_rr(dev, WF_PSE_TOP_HIF1_PG_INFO_ADDR);
+	pg_flow_ctrl[6] = mt76_rr(dev, WF_PSE_TOP_PG_CPU_GROUP_ADDR);
+	pg_flow_ctrl[7] = mt76_rr(dev, WF_PSE_TOP_CPU_PG_INFO_ADDR);
+	pg_flow_ctrl[8] = mt76_rr(dev, WF_PSE_TOP_PG_LMAC0_GROUP_ADDR);
+	pg_flow_ctrl[9] = mt76_rr(dev, WF_PSE_TOP_LMAC0_PG_INFO_ADDR);
+	pg_flow_ctrl[10] = mt76_rr(dev, WF_PSE_TOP_PG_LMAC1_GROUP_ADDR);
+	pg_flow_ctrl[11] = mt76_rr(dev, WF_PSE_TOP_LMAC1_PG_INFO_ADDR);
+	pg_flow_ctrl[12] = mt76_rr(dev, WF_PSE_TOP_PG_LMAC2_GROUP_ADDR);
+	pg_flow_ctrl[13] = mt76_rr(dev, WF_PSE_TOP_LMAC2_PG_INFO_ADDR);
+	pg_flow_ctrl[14] = mt76_rr(dev, WF_PSE_TOP_PG_PLE_GROUP_ADDR);
+	pg_flow_ctrl[15] = mt76_rr(dev, WF_PSE_TOP_PLE_PG_INFO_ADDR);
+	pg_flow_ctrl[16] = mt76_rr(dev, WF_PSE_TOP_PG_LMAC3_GROUP_ADDR);
+	pg_flow_ctrl[17] = mt76_rr(dev, WF_PSE_TOP_LMAC3_PG_INFO_ADDR);
+	pg_flow_ctrl[18] = mt76_rr(dev, WF_PSE_TOP_PG_MDP_GROUP_ADDR);
+	pg_flow_ctrl[19] = mt76_rr(dev, WF_PSE_TOP_MDP_PG_INFO_ADDR);
+	pg_flow_ctrl[20] = mt76_rr(dev, WF_PSE_TOP_PG_PLE1_GROUP_ADDR);
+	pg_flow_ctrl[21] = mt76_rr(dev, WF_PSE_TOP_PLE1_PG_INFO_ADDR);
+	pg_flow_ctrl[22] = mt76_rr(dev, WF_PSE_TOP_PG_MDP2_GROUP_ADDR);
+	pg_flow_ctrl[23] = mt76_rr(dev, WF_PSE_TOP_MDP2_PG_INFO_ADDR);
+	if (mt7996_band_valid(dev, MT_BAND2)) {
+		pg_flow_ctrl[24] = mt76_rr(dev, WF_PSE_TOP_PG_MDP3_GROUP_ADDR);
+		pg_flow_ctrl[25] = mt76_rr(dev, WF_PSE_TOP_MDP3_PG_INFO_ADDR);
+	}
+	pg_flow_ctrl[26] = mt76_rr(dev, WF_PSE_TOP_PG_HIF2_GROUP_ADDR);
+	pg_flow_ctrl[27] = mt76_rr(dev, WF_PSE_TOP_HIF2_PG_INFO_ADDR);
+	/* Configuration Info */
+	seq_printf(s, "PSE Configuration Info:\n");
+	seq_printf(s, "\tPacket Buffer Control: 0x%08x\n", pse_buf_ctrl);
+	pg_sz = (pse_buf_ctrl & WF_PSE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_MASK) >> WF_PSE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_SHFT;
+	seq_printf(s, "\t\tPage Size=%d(%d bytes per page)\n", pg_sz, (pg_sz == 1 ? 256 : 128));
+	seq_printf(s, "\t\tPage Offset=%d(in unit of 64KB)\n",
+			 (pse_buf_ctrl & WF_PSE_TOP_PBUF_CTRL_PBUF_OFFSET_MASK) >> WF_PSE_TOP_PBUF_CTRL_PBUF_OFFSET_SHFT);
+	pg_num = (pse_buf_ctrl & WF_PSE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_MASK) >> WF_PSE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_SHFT;
+	seq_printf(s, "\t\tTotal page numbers=%d pages\n", pg_num);
+	/* Page Flow Control */
+	seq_printf(s, "PSE Page Flow Control:\n");
+	seq_printf(s, "\tFree page counter: 0x%08x\n", pg_flow_ctrl[0]);
+	fpg_cnt = (pg_flow_ctrl[0] & WF_PSE_TOP_FREEPG_CNT_FREEPG_CNT_MASK) >> WF_PSE_TOP_FREEPG_CNT_FREEPG_CNT_SHFT;
+	seq_printf(s, "\t\tThe toal page number of free=0x%03x\n", fpg_cnt);
+	ffa_cnt = (pg_flow_ctrl[0] & WF_PSE_TOP_FREEPG_CNT_FFA_CNT_MASK) >> WF_PSE_TOP_FREEPG_CNT_FFA_CNT_SHFT;
+	seq_printf(s, "\t\tThe free page numbers of free for all=0x%03x\n", ffa_cnt);
+	seq_printf(s, "\tFree page head and tail: 0x%08x\n", pg_flow_ctrl[1]);
+	fpg_head = (pg_flow_ctrl[1] & WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_MASK) >> WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_SHFT;
+	fpg_tail = (pg_flow_ctrl[1] & WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_MASK) >> WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_SHFT;
+	seq_printf(s, "\t\tThe tail/head page of free page list=0x%03x/0x%03x\n", fpg_tail, fpg_head);
+	seq_printf(s, "\tReserved page counter of HIF0 group: 0x%08x\n", pg_flow_ctrl[2]);
+	seq_printf(s, "\tHIF0 group page status: 0x%08x\n", pg_flow_ctrl[3]);
+	min_q = (pg_flow_ctrl[2] & WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[2] & WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of HIF0 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[3] & WF_PSE_TOP_HIF0_PG_INFO_HIF0_RSV_CNT_MASK) >> WF_PSE_TOP_HIF0_PG_INFO_HIF0_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[3] & WF_PSE_TOP_HIF0_PG_INFO_HIF0_SRC_CNT_MASK) >> WF_PSE_TOP_HIF0_PG_INFO_HIF0_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of HIF0 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of HIF1 group: 0x%08x\n", pg_flow_ctrl[4]);
+	seq_printf(s, "\tHIF1 group page status: 0x%08x\n", pg_flow_ctrl[5]);
+	min_q = (pg_flow_ctrl[4] & WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[4] & WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of HIF1 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[5] & WF_PSE_TOP_HIF1_PG_INFO_HIF1_RSV_CNT_MASK) >> WF_PSE_TOP_HIF1_PG_INFO_HIF1_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[5] & WF_PSE_TOP_HIF1_PG_INFO_HIF1_SRC_CNT_MASK) >> WF_PSE_TOP_HIF1_PG_INFO_HIF1_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of HIF1 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of HIF2 group: 0x%08x\n", pg_flow_ctrl[26]);
+	seq_printf(s, "\tHIF2 group page status: 0x%08x\n", pg_flow_ctrl[27]);
+	min_q = (pg_flow_ctrl[26] & WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[26] & WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of HIF2 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[27] & WF_PSE_TOP_HIF2_PG_INFO_HIF2_RSV_CNT_MASK) >> WF_PSE_TOP_HIF2_PG_INFO_HIF2_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[27] & WF_PSE_TOP_HIF2_PG_INFO_HIF2_SRC_CNT_MASK) >> WF_PSE_TOP_HIF2_PG_INFO_HIF2_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of HIF2 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of CPU group: 0x%08x\n", pg_flow_ctrl[6]);
+	seq_printf(s, "\tCPU group page status: 0x%08x\n", pg_flow_ctrl[7]);
+	min_q = (pg_flow_ctrl[6] & WF_PSE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[6] & WF_PSE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of CPU group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[7] & WF_PSE_TOP_CPU_PG_INFO_CPU_RSV_CNT_MASK) >> WF_PSE_TOP_CPU_PG_INFO_CPU_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[7] & WF_PSE_TOP_CPU_PG_INFO_CPU_SRC_CNT_MASK) >> WF_PSE_TOP_CPU_PG_INFO_CPU_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of CPU group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of LMAC0 group: 0x%08x\n", pg_flow_ctrl[8]);
+	seq_printf(s, "\tLMAC0 group page status: 0x%08x\n", pg_flow_ctrl[9]);
+	min_q = (pg_flow_ctrl[8] & WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[8] & WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of LMAC0 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[9] & WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_RSV_CNT_MASK) >> WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[9] & WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_SRC_CNT_MASK) >> WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of LMAC0 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of LMAC1 group: 0x%08x\n", pg_flow_ctrl[10]);
+	seq_printf(s, "\tLMAC1 group page status: 0x%08x\n", pg_flow_ctrl[11]);
+	min_q = (pg_flow_ctrl[10] & WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[10] & WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of LMAC1 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[11] & WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_RSV_CNT_MASK) >> WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[11] & WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_SRC_CNT_MASK) >> WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of LMAC1 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of LMAC2 group: 0x%08x\n", pg_flow_ctrl[11]);
+	seq_printf(s, "\tLMAC2 group page status: 0x%08x\n", pg_flow_ctrl[12]);
+	min_q = (pg_flow_ctrl[12] & WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[12] & WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of LMAC2 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[13] & WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_RSV_CNT_MASK) >> WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[13] & WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_SRC_CNT_MASK) >> WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of LMAC2 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+
+	seq_printf(s, "\tReserved page counter of LMAC3 group: 0x%08x\n", pg_flow_ctrl[16]);
+	seq_printf(s, "\tLMAC3 group page status: 0x%08x\n", pg_flow_ctrl[17]);
+	min_q = (pg_flow_ctrl[16] & WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[16] & WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of LMAC3 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[17] & WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_RSV_CNT_MASK) >> WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[17] & WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_SRC_CNT_MASK) >> WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of LMAC3 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+
+	seq_printf(s, "\tReserved page counter of PLE group: 0x%08x\n", pg_flow_ctrl[14]);
+	seq_printf(s, "\tPLE group page status: 0x%08x\n", pg_flow_ctrl[15]);
+	min_q = (pg_flow_ctrl[14] & WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[14] & WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of PLE group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[15] & WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_MASK) >> WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[15] & WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_MASK) >> WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of PLE group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+
+	seq_printf(s, "\tReserved page counter of PLE1 group: 0x%08x\n", pg_flow_ctrl[14]);
+	seq_printf(s, "\tPLE1 group page status: 0x%08x\n", pg_flow_ctrl[15]);
+	min_q = (pg_flow_ctrl[20] & WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[20] & WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of PLE1 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[21] & WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_MASK) >> WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[21] & WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_MASK) >> WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of PLE1 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+
+	seq_printf(s, "\tReserved page counter of MDP group: 0x%08x\n", pg_flow_ctrl[18]);
+	seq_printf(s, "\tMDP group page status: 0x%08x\n", pg_flow_ctrl[19]);
+	min_q = (pg_flow_ctrl[18] & WF_PSE_TOP_PG_MDP_GROUP_MDP_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP_GROUP_MDP_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[18] & WF_PSE_TOP_PG_MDP_GROUP_MDP_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP_GROUP_MDP_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of MDP group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[19] & WF_PSE_TOP_MDP_PG_INFO_MDP_RSV_CNT_MASK) >> WF_PSE_TOP_MDP_PG_INFO_MDP_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[19] & WF_PSE_TOP_MDP_PG_INFO_MDP_SRC_CNT_MASK) >> WF_PSE_TOP_MDP_PG_INFO_MDP_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of MDP group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of MDP2 group: 0x%08x\n", pg_flow_ctrl[22]);
+	seq_printf(s, "\tMDP2 group page status: 0x%08x\n", pg_flow_ctrl[23]);
+	min_q = (pg_flow_ctrl[22] & WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[22] & WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of MDP2 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[23] & WF_PSE_TOP_MDP2_PG_INFO_MDP2_RSV_CNT_MASK) >> WF_PSE_TOP_MDP2_PG_INFO_MDP2_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[23] & WF_PSE_TOP_MDP2_PG_INFO_MDP2_SRC_CNT_MASK) >> WF_PSE_TOP_MDP2_PG_INFO_MDP2_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of MDP2 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	if (mt7996_band_valid(dev, MT_BAND2)) {
+		seq_printf(s, "\tReserved page counter of MDP3 group: 0x%08x\n", pg_flow_ctrl[24]);
+		seq_printf(s, "\tMDP3 group page status: 0x%08x\n", pg_flow_ctrl[25]);
+		min_q = (pg_flow_ctrl[24] & WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MIN_QUOTA_SHFT;
+		max_q = (pg_flow_ctrl[24] & WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MAX_QUOTA_SHFT;
+		seq_printf(s, "\t\tThe max/min quota pages of MDP3 group=0x%03x/0x%03x\n", max_q, min_q);
+		rsv_pg = (pg_flow_ctrl[25] & WF_PSE_TOP_MDP3_PG_INFO_MDP3_RSV_CNT_MASK) >> WF_PSE_TOP_MDP3_PG_INFO_MDP3_RSV_CNT_SHFT;
+		used_pg = (pg_flow_ctrl[25] & WF_PSE_TOP_MDP3_PG_INFO_MDP3_SRC_CNT_MASK) >> WF_PSE_TOP_MDP3_PG_INFO_MDP3_SRC_CNT_SHFT;
+		seq_printf(s, "\t\tThe used/reserved pages of MDP3 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	}
+	/* Queue Empty Status */
+	seq_printf(s, "PSE Queue Empty Status:\n");
+	seq_printf(s, "\tQUEUE_EMPTY: 0x%08x, QUEUE_EMPTY2: 0x%08x\n", pse_stat[0], pse_stat[1]);
+	seq_printf(s, "\t\tCPU Q0/1/2/3/4 empty=%d/%d/%d/%d/%d\n",
+			  (pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q0_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q0_EMPTY_SHFT,
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q1_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q1_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q2_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q2_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q3_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q3_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q4_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q4_EMPTY_SHFT));
+	seq_printf(s, "\t\tHIF Q0/1/2/3/4/5/6/7/8/9/10/11/12/13 empty=%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d\n",
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_0_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_0_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_1_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_1_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_2_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_2_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_3_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_3_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_4_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_4_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_5_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_5_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_6_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_6_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_7_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_7_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_8_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_8_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_9_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_9_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_10_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_10_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_11_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_11_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_12_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_12_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_SHFT));
+	seq_printf(s, "\t\tLMAC TX Q empty=%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_LMAC_TX_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_LMAC_TX_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tMDP TX Q0/Q1/Q2/RX Q empty=%d/%d/%d/%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_TX_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_TX_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_TX1_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_TX1_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TX2_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TX2_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_RX_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_RX_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tSEC TX Q0/Q1/Q2/RX Q empty=%d/%d/%d/%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_SEC_TX_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_SEC_TX_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_SEC_TX1_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_SEC_TX1_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_SEC_TX2_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_SEC_TX2_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_SEC_RX_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_SEC_RX_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tSFD PARK Q empty=%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_SFD_PARK_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_SFD_PARK_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tMDP TXIOC Q0/Q1/Q2 empty=%d/%d/%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC1_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC1_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TXIOC2_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TXIOC2_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tMDP RXIOC Q0/Q1/Q2/Q3 empty=%d/%d/%d/%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC1_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC1_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC2_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC2_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC3_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC3_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tRLS Q empty=%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_RLS_Q_EMTPY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_RLS_Q_EMTPY_SHFT));
+	seq_printf(s, "Nonempty Q info:\n");
+
+	for (i = 0; i < 31; i++) {
+		if (((pse_stat[0] & (0x1 << i)) >> i) == 0) {
+			u32 hfid, tfid, pktcnt, fl_que_ctrl[3] = {0};
+
+			if (pse_queue_empty_info[i].QueueName != NULL) {
+				seq_printf(s, "\t%s: ", pse_queue_empty_info[i].QueueName);
+				fl_que_ctrl[0] |= WF_PSE_TOP_FL_QUE_CTRL_0_EXECUTE_MASK;
+				fl_que_ctrl[0] |= (pse_queue_empty_info[i].Portid << WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_SHFT);
+				fl_que_ctrl[0] |= (pse_queue_empty_info[i].Queueid << WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_SHFT);
+			} else
+				continue;
+
+			fl_que_ctrl[0] |= (0x1 << 31);
+			mt76_wr(dev, WF_PSE_TOP_FL_QUE_CTRL_0_ADDR, fl_que_ctrl[0]);
+			fl_que_ctrl[1] = mt76_rr(dev, WF_PSE_TOP_FL_QUE_CTRL_2_ADDR);
+			fl_que_ctrl[2] = mt76_rr(dev, WF_PSE_TOP_FL_QUE_CTRL_3_ADDR);
+			hfid = (fl_que_ctrl[1] & WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_SHFT;
+			tfid = (fl_que_ctrl[1] & WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_SHFT;
+			pktcnt = (fl_que_ctrl[2] & WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_SHFT;
+			seq_printf(s, "tail/head fid = 0x%03x/0x%03x, pkt cnt = 0x%03x\n",
+					  tfid, hfid, pktcnt);
+		}
+	}
+
+	for (i = 0; i < 31; i++) {
+		if (((pse_stat[1] & (0x1 << i)) >> i) == 0) {
+			u32 hfid, tfid, pktcnt, fl_que_ctrl[3] = {0};
+
+			if (pse_queue_empty2_info[i].QueueName != NULL) {
+				seq_printf(s, "\t%s: ", pse_queue_empty2_info[i].QueueName);
+				fl_que_ctrl[0] |= WF_PSE_TOP_FL_QUE_CTRL_0_EXECUTE_MASK;
+				fl_que_ctrl[0] |= (pse_queue_empty2_info[i].Portid << WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_SHFT);
+				fl_que_ctrl[0] |= (pse_queue_empty2_info[i].Queueid << WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_SHFT);
+			} else
+				continue;
+
+			fl_que_ctrl[0] |= (0x1 << 31);
+			mt76_wr(dev, WF_PSE_TOP_FL_QUE_CTRL_0_ADDR, fl_que_ctrl[0]);
+			fl_que_ctrl[1] = mt76_rr(dev, WF_PSE_TOP_FL_QUE_CTRL_2_ADDR);
+			fl_que_ctrl[2] = mt76_rr(dev, WF_PSE_TOP_FL_QUE_CTRL_3_ADDR);
+			hfid = (fl_que_ctrl[1] & WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_SHFT;
+			tfid = (fl_que_ctrl[1] & WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_SHFT;
+			pktcnt = (fl_que_ctrl[2] & WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_SHFT;
+			seq_printf(s, "tail/head fid = 0x%03x/0x%03x, pkt cnt = 0x%03x\n",
+					  tfid, hfid, pktcnt);
+		}
+	}
+
+	return 0;
+}
+
+/* PLE INFO */
+static char *sta_ctrl_reg[] = {"ENABLE", "DISABLE", "PAUSE", "TWT_PAUSE"};
+static struct bmac_queue_info ple_queue_empty_info[] = {
+	{"CPU Q0",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_0, 0},
+	{"CPU Q1",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_1, 0},
+	{"CPU Q2",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_2, 0},
+	{"CPU Q3",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_3, 0},
+	{"ALTX Q0", ENUM_UMAC_LMAC_PORT_2,    0x10, 0},
+	{"BMC Q0",  ENUM_UMAC_LMAC_PORT_2,    0x11, 0},
+	{"BCN Q0",  ENUM_UMAC_LMAC_PORT_2,    0x12, 0},
+	{"PSMP Q0", ENUM_UMAC_LMAC_PORT_2,    0x13, 0},
+	{"ALTX Q1", ENUM_UMAC_LMAC_PORT_2,    0x10, 1},
+	{"BMC Q1",  ENUM_UMAC_LMAC_PORT_2,    0x11, 1},
+	{"BCN Q1",  ENUM_UMAC_LMAC_PORT_2,    0x12, 1},
+	{"PSMP Q1", ENUM_UMAC_LMAC_PORT_2,    0x13, 1},
+	{"ALTX Q2", ENUM_UMAC_LMAC_PORT_2,    0x10, 2},
+	{"BMC Q2",  ENUM_UMAC_LMAC_PORT_2,    0x11, 2},
+	{"BCN Q2",  ENUM_UMAC_LMAC_PORT_2,    0x12, 2},
+	{"PSMP Q2", ENUM_UMAC_LMAC_PORT_2,    0x13, 2},
+	{"NAF Q",   ENUM_UMAC_LMAC_PORT_2,    0x18, 0},
+	{"NBCN Q",  ENUM_UMAC_LMAC_PORT_2,    0x19, 0},
+	{NULL, 0, 0, 0}, {NULL, 0, 0, 0}, /* 18, 19 not defined */
+	{"FIXFID Q", ENUM_UMAC_LMAC_PORT_2, 0x1a, 0},
+	{NULL, 0, 0, 0}, {NULL, 0, 0, 0}, {NULL, 0, 0, 0}, {NULL, 0, 0, 0}, {NULL, 0, 0, 0},
+	{NULL, 0, 0, 0}, {NULL, 0, 0, 0},
+	{"RLS4 Q",   ENUM_PLE_CTRL_PSE_PORT_3, 0x7c, 0},
+	{"RLS3 Q",   ENUM_PLE_CTRL_PSE_PORT_3, 0x7d, 0},
+	{"RLS2 Q",   ENUM_PLE_CTRL_PSE_PORT_3, 0x7e, 0},
+	{"RLS Q",  ENUM_PLE_CTRL_PSE_PORT_3, 0x7f, 0}
+};
+
+static struct bmac_queue_info_t ple_txcmd_queue_empty_info[] = {
+	{"AC00Q", ENUM_UMAC_LMAC_PORT_2, 0x40},
+	{"AC01Q", ENUM_UMAC_LMAC_PORT_2, 0x41},
+	{"AC02Q", ENUM_UMAC_LMAC_PORT_2, 0x42},
+	{"AC03Q", ENUM_UMAC_LMAC_PORT_2, 0x43},
+	{"AC10Q", ENUM_UMAC_LMAC_PORT_2, 0x44},
+	{"AC11Q", ENUM_UMAC_LMAC_PORT_2, 0x45},
+	{"AC12Q", ENUM_UMAC_LMAC_PORT_2, 0x46},
+	{"AC13Q", ENUM_UMAC_LMAC_PORT_2, 0x47},
+	{"AC20Q", ENUM_UMAC_LMAC_PORT_2, 0x48},
+	{"AC21Q", ENUM_UMAC_LMAC_PORT_2, 0x49},
+	{"AC22Q", ENUM_UMAC_LMAC_PORT_2, 0x4a},
+	{"AC23Q", ENUM_UMAC_LMAC_PORT_2, 0x4b},
+	{"AC30Q", ENUM_UMAC_LMAC_PORT_2, 0x4c},
+	{"AC31Q", ENUM_UMAC_LMAC_PORT_2, 0x4d},
+	{"AC32Q", ENUM_UMAC_LMAC_PORT_2, 0x4e},
+	{"AC33Q", ENUM_UMAC_LMAC_PORT_2, 0x4f},
+	{"ALTX Q0", ENUM_UMAC_LMAC_PORT_2, 0x50},
+	{"TF Q0", ENUM_UMAC_LMAC_PORT_2, 0x51},
+	{"TWT TSF-TF Q0", ENUM_UMAC_LMAC_PORT_2, 0x52},
+	{"TWT DL Q0", ENUM_UMAC_LMAC_PORT_2, 0x53},
+	{"TWT UL Q0", ENUM_UMAC_LMAC_PORT_2, 0x54},
+	{NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	{NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+};
+
+static void
+mt7996_get_ple_acq_stat(struct mt7996_dev *dev, u32 *ple_stat)
+{
+	u32 i, addr;
+
+	ple_stat[0] = mt76_rr(dev, WF_PLE_TOP_QUEUE_EMPTY_ADDR);
+
+	/* Legacy */
+	addr = WF_PLE_TOP_AC0_QUEUE_EMPTY0_ADDR;
+	for (i = 1; i <= CR_NUM_OF_AC; i++, addr += 4)
+		ple_stat[i] = mt76_rr(dev, addr);
+
+	addr = WF_PLE_TOP_AC1_QUEUE_EMPTY0_ADDR;
+	for (; i <= CR_NUM_OF_AC * 2; i++, addr += 4)
+		ple_stat[i] = mt76_rr(dev, addr);
+
+	addr = WF_PLE_TOP_AC2_QUEUE_EMPTY0_ADDR;
+	for (; i <= CR_NUM_OF_AC * 3; i++, addr += 4)
+		ple_stat[i] = mt76_rr(dev, addr);
+
+	addr = WF_PLE_TOP_AC3_QUEUE_EMPTY0_ADDR;
+	for (; i <= CR_NUM_OF_AC * 4; i++, addr += 4)
+		ple_stat[i] = mt76_rr(dev, addr);
+}
+
+static void
+mt7996_get_ple_txcmd_stat(struct mt7996_dev *dev, u32 *ple_txcmd_stat)
+{
+	*ple_txcmd_stat = mt76_rr(dev, WF_PLE_TOP_NATIVE_TXCMD_QUEUE_EMPTY_ADDR);
+}
+
+static void
+mt7996_get_sta_pause(struct mt7996_dev *dev, u8 band, u32 *sta_pause, u32 *twt_pause)
+{
+	u32 i, addr;
+
+	/* switch to target band */
+	mt76_wr(dev, WF_DRR_TOP_SBRR_ADDR, u32_encode_bits(band, WF_DRR_TOP_SBRR_TARGET_BAND_MASK));
+
+	/* Legacy */
+	addr = WF_DRR_TOP_AC0_STATION_PAUSE00_ADDR;
+	for (i = 0; i < CR_NUM_OF_AC; i++, addr += 4)
+		sta_pause[i] = mt76_rr(dev, addr);
+
+	addr = WF_DRR_TOP_AC1_STATION_PAUSE00_ADDR;
+	for (; i < CR_NUM_OF_AC * 2; i++, addr += 4)
+		sta_pause[i] = mt76_rr(dev, addr);
+
+	addr = WF_DRR_TOP_AC2_STATION_PAUSE00_ADDR;
+	for (; i < CR_NUM_OF_AC * 3; i++, addr += 4)
+		sta_pause[i] = mt76_rr(dev, addr);
+
+	addr = WF_DRR_TOP_AC3_STATION_PAUSE00_ADDR;
+	for (; i < CR_NUM_OF_AC * 4; i++, addr += 4)
+		sta_pause[i] = mt76_rr(dev, addr);
+
+	/* TWT */
+	addr = WF_DRR_TOP_TWT_STA_MAP00_ADDR;
+	for (i = 0; i < CR_NUM_OF_AC; i++, addr += 4)
+		twt_pause[i] = mt76_rr(dev, addr);
+
+}
+
+static int
+mt7996_show_sta_acq_info(struct seq_file *s, u32 *ple_stat,
+			 u32 *sta_pause, u32 *twt_sta_pause,
+			 u32 dumptxd)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	int i, j;
+	u32 total_nonempty_cnt = 0;
+
+	for (j = 0; j < ALL_CR_NUM_OF_ALL_AC; j++) { /* show AC Q info */
+		for (i = 0; i < 32; i++) {
+			if (((ple_stat[j + 1] & (0x1 << i)) >> i) == 0) {
+				u32 hfid, tfid, pktcnt, ac_num = j / CR_NUM_OF_AC, ctrl = 0;
+				u32 sta_num = i + (j % CR_NUM_OF_AC) * 32, fl_que_ctrl[3] = {0};
+				u32 wmmidx = 0;
+				u8 band, idx;
+				struct mt7996_sta *msta;
+				struct mt76_wcid *wcid;
+
+				wcid = rcu_dereference(dev->mt76.wcid[sta_num]);
+				if (!wcid) {
+					seq_printf(s, "ERROR!! no found STA wcid=%d\n", sta_num);
+					return 0;
+				}
+				msta = container_of(wcid, struct mt7996_sta, wcid);
+				wmmidx = msta->vif->deflink.mt76.wmm_idx;
+
+				seq_printf(s, "\tSTA%d AC%d: ", sta_num, ac_num);
+
+				fl_que_ctrl[0] |= WF_PLE_TOP_FL_QUE_CTRL_0_EXECUTE_MASK;
+				fl_que_ctrl[0] |= (ENUM_UMAC_LMAC_PORT_2 << WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_SHFT);
+				fl_que_ctrl[0] |= (ac_num << WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_SHFT);
+				fl_que_ctrl[0] |= (sta_num << WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_WLANID_SHFT);
+				mt76_wr(dev, WF_PLE_TOP_FL_QUE_CTRL_0_ADDR, fl_que_ctrl[0]);
+				fl_que_ctrl[1] = mt76_rr(dev, WF_PLE_TOP_FL_QUE_CTRL_2_ADDR);
+				fl_que_ctrl[2] = mt76_rr(dev, WF_PLE_TOP_FL_QUE_CTRL_3_ADDR);
+				hfid = (fl_que_ctrl[1] & WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_MASK) >>
+					WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_SHFT;
+				tfid = (fl_que_ctrl[1] & WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_MASK) >>
+					WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_SHFT;
+				pktcnt = (fl_que_ctrl[2] & WF_PLE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_MASK) >>
+					WF_PLE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_SHFT;
+				seq_printf(s, "tail/head fid = 0x%03x/0x%03x, pkt cnt = 0x%03x",
+						  tfid, hfid, pktcnt);
+
+				band = wcid->phy_idx;
+
+				idx = band * ALL_CR_NUM_OF_ALL_AC + j;
+				if (sta_pause[idx] & BIT(i))
+					ctrl = 2;
+
+				idx = band * CR_NUM_OF_AC + j % CR_NUM_OF_AC;
+				if (twt_sta_pause[idx] & BIT(i))
+					ctrl = 3;
+
+				seq_printf(s, " ctrl = %s", sta_ctrl_reg[ctrl]);
+				seq_printf(s, " (wmmidx=%d, band=%d)\n", wmmidx, band);
+
+				total_nonempty_cnt++;
+
+				if (pktcnt > 0 && dumptxd > 0)
+					mt7996_dump_mac_fid(s, dev, hfid, true);
+			}
+		}
+	}
+
+	return total_nonempty_cnt;
+}
+
+static void
+mt7996_show_txcmdq_info(struct seq_file *s, u32 ple_txcmd_stat)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	int i;
+
+	seq_printf(s, "Nonempty TXCMD Q info:\n");
+	for (i = 0; i < 32 ; i++) {
+		if (((ple_txcmd_stat & (0x1 << i)) >> i) == 0) {
+			u32 hfid, tfid, pktcnt, fl_que_ctrl[3] = {0};
+
+			if (ple_txcmd_queue_empty_info[i].QueueName != NULL) {
+				seq_printf(s, "\t%s: ", ple_txcmd_queue_empty_info[i].QueueName);
+				fl_que_ctrl[0] |= WF_PLE_TOP_FL_QUE_CTRL_0_EXECUTE_MASK;
+				fl_que_ctrl[0] |= (ple_txcmd_queue_empty_info[i].Portid <<
+							WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_SHFT);
+				fl_que_ctrl[0] |= (ple_txcmd_queue_empty_info[i].Queueid <<
+							WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_SHFT);
+				mt76_wr(dev, WF_PLE_TOP_FL_QUE_CTRL_0_ADDR, fl_que_ctrl[0]);
+			} else
+				continue;
+
+			fl_que_ctrl[1] = mt76_rr(dev, WF_PLE_TOP_FL_QUE_CTRL_2_ADDR);
+			fl_que_ctrl[2] = mt76_rr(dev, WF_PLE_TOP_FL_QUE_CTRL_3_ADDR);
+			hfid = (fl_que_ctrl[1] & WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_MASK) >>
+				WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_SHFT;
+			tfid = (fl_que_ctrl[1] & WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_MASK) >>
+				WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_SHFT;
+			pktcnt = (fl_que_ctrl[2] & WF_PLE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_MASK) >>
+				WF_PLE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_SHFT;
+			seq_printf(s, "tail/head fid = 0x%03x/0x%03x, pkt cnt = 0x%03x\n",
+					  tfid, hfid, pktcnt);
+		}
+	}
+}
+
+static int
+mt7996_pleinfo_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	u32 ple_buf_ctrl, pg_sz, pg_num;
+	u32 ple_stat[ALL_CR_NUM_OF_ALL_AC + 1] = {0}, pg_flow_ctrl[10] = {0};
+	u32 ple_native_txcmd_stat;
+	u32 ple_txcmd_stat;
+	u32 *sta_pause, *twt_sta_pause;
+	u32 fpg_cnt, ffa_cnt, fpg_head, fpg_tail, hif_max_q, hif_min_q;
+	u32 rpg_hif, upg_hif, cpu_max_q, cpu_min_q, rpg_cpu, upg_cpu;
+	int i, j;
+	u32 dumptxd = dev->dbg.dump_ple_txd;
+
+	sta_pause = kzalloc(CFG_WIFI_RAM_BAND_NUM * ALL_CR_NUM_OF_ALL_AC * sizeof(u32), GFP_KERNEL);
+	if (!sta_pause)
+		return -ENOMEM;
+
+	twt_sta_pause = kzalloc(CFG_WIFI_RAM_BAND_NUM * CR_NUM_OF_AC * sizeof(u32), GFP_KERNEL);
+	if (!twt_sta_pause) {
+		kfree(sta_pause);
+		return -ENOMEM;
+	}
+
+	ple_buf_ctrl = mt76_rr(dev, WF_PLE_TOP_PBUF_CTRL_ADDR);
+	mt7996_get_ple_acq_stat(dev, ple_stat);
+	ple_txcmd_stat = mt76_rr(dev, WF_PLE_TOP_TXCMD_QUEUE_EMPTY_ADDR);
+	mt7996_get_ple_txcmd_stat(dev, &ple_native_txcmd_stat);
+	pg_flow_ctrl[0] = mt76_rr(dev, WF_PLE_TOP_FREEPG_CNT_ADDR);
+	pg_flow_ctrl[1] = mt76_rr(dev, WF_PLE_TOP_FREEPG_HEAD_TAIL_ADDR);
+	pg_flow_ctrl[2] = mt76_rr(dev, WF_PLE_TOP_PG_HIF_GROUP_ADDR);
+	pg_flow_ctrl[3] = mt76_rr(dev, WF_PLE_TOP_HIF_PG_INFO_ADDR);
+	pg_flow_ctrl[4] = mt76_rr(dev, WF_PLE_TOP_PG_CPU_GROUP_ADDR);
+	pg_flow_ctrl[5] = mt76_rr(dev, WF_PLE_TOP_CPU_PG_INFO_ADDR);
+	pg_flow_ctrl[6] = mt76_rr(dev, WF_PLE_TOP_PG_HIF_TXCMD_GROUP_ADDR);
+	pg_flow_ctrl[7] = mt76_rr(dev, WF_PLE_TOP_HIF_TXCMD_PG_INFO_ADDR);
+	pg_flow_ctrl[8] = mt76_rr(dev, WF_PLE_TOP_PG_HIF_WMTXD_GROUP_ADDR);
+	pg_flow_ctrl[9] = mt76_rr(dev, WF_PLE_TOP_HIF_WMTXD_PG_INFO_ADDR);
+
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		if (!dev->mt76.phys[i])
+			continue;
+
+		mt7996_get_sta_pause(dev, i,
+				     sta_pause + i * ALL_CR_NUM_OF_ALL_AC,
+				     twt_sta_pause + i * CR_NUM_OF_AC);
+	}
+
+	/* Configuration Info */
+	seq_printf(s, "PLE Configuration Info:\n");
+	seq_printf(s, "\tPacket Buffer Control(0x82060014): 0x%08x\n", ple_buf_ctrl);
+	pg_sz = (ple_buf_ctrl & WF_PLE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_MASK) >> WF_PLE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_SHFT;
+	seq_printf(s, "\t\tPage Size=%d(%d bytes per page)\n", pg_sz, (pg_sz == 1 ? 128 : 64));
+	seq_printf(s, "\t\tPage Offset=%d(in unit of 2KB)\n",
+			 (ple_buf_ctrl & WF_PLE_TOP_PBUF_CTRL_PBUF_OFFSET_MASK) >> WF_PLE_TOP_PBUF_CTRL_PBUF_OFFSET_SHFT);
+	pg_num = (ple_buf_ctrl & WF_PLE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_MASK) >> WF_PLE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_SHFT;
+	seq_printf(s, "\t\tTotal Page=%d pages\n", pg_num);
+
+	/* Page Flow Control */
+	seq_printf(s, "PLE Page Flow Control:\n");
+	seq_printf(s, "\tFree page counter: 0x%08x\n", pg_flow_ctrl[0]);
+	fpg_cnt = (pg_flow_ctrl[0] & WF_PLE_TOP_FREEPG_CNT_FREEPG_CNT_MASK) >> WF_PLE_TOP_FREEPG_CNT_FREEPG_CNT_SHFT;
+	seq_printf(s, "\t\tThe toal page number of free=0x%03x\n", fpg_cnt);
+	ffa_cnt = (pg_flow_ctrl[0] & WF_PLE_TOP_FREEPG_CNT_FFA_CNT_MASK) >> WF_PLE_TOP_FREEPG_CNT_FFA_CNT_SHFT;
+	seq_printf(s, "\t\tThe free page numbers of free for all=0x%03x\n", ffa_cnt);
+	seq_printf(s, "\tFree page head and tail: 0x%08x\n", pg_flow_ctrl[1]);
+	fpg_head = (pg_flow_ctrl[1] & WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_MASK) >> WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_SHFT;
+	fpg_tail = (pg_flow_ctrl[1] & WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_MASK) >> WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_SHFT;
+	seq_printf(s, "\t\tThe tail/head page of free page list=0x%03x/0x%03x\n", fpg_tail, fpg_head);
+	seq_printf(s, "\tReserved page counter of HIF group: 0x%08x\n", pg_flow_ctrl[2]);
+	seq_printf(s, "\tHIF group page status: 0x%08x\n", pg_flow_ctrl[3]);
+	hif_min_q = (pg_flow_ctrl[2] & WF_PLE_TOP_PG_HIF_GROUP_HIF_MIN_QUOTA_MASK) >> WF_PLE_TOP_PG_HIF_GROUP_HIF_MIN_QUOTA_SHFT;
+	hif_max_q = (pg_flow_ctrl[2] & WF_PLE_TOP_PG_HIF_GROUP_HIF_MAX_QUOTA_MASK) >> WF_PLE_TOP_PG_HIF_GROUP_HIF_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of HIF group=0x%03x/0x%03x\n", hif_max_q, hif_min_q);
+	rpg_hif = (pg_flow_ctrl[3] & WF_PLE_TOP_HIF_PG_INFO_HIF_RSV_CNT_MASK) >> WF_PLE_TOP_HIF_PG_INFO_HIF_RSV_CNT_SHFT;
+	upg_hif = (pg_flow_ctrl[3] & WF_PLE_TOP_HIF_PG_INFO_HIF_SRC_CNT_MASK) >> WF_PLE_TOP_HIF_PG_INFO_HIF_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of HIF group=0x%03x/0x%03x\n", upg_hif, rpg_hif);
+
+	seq_printf(s, "\tReserved page counter of WMTXD group: 0x%08x\n", pg_flow_ctrl[8]);
+	seq_printf(s, "\tWMTXD group page status: 0x%08x\n", pg_flow_ctrl[9]);
+	cpu_min_q = (pg_flow_ctrl[8] & WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MIN_QUOTA_MASK) >> WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MIN_QUOTA_SHFT;
+	cpu_max_q = (pg_flow_ctrl[8] & WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MAX_QUOTA_MASK) >> WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of WMTXD group=0x%03x/0x%03x\n", cpu_max_q, cpu_min_q);
+	rpg_cpu = (pg_flow_ctrl[9] & WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_RSV_CNT_MASK) >> WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_RSV_CNT_SHFT;
+	upg_cpu = (pg_flow_ctrl[9] & WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_SRC_CNT_MASK) >> WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of WMTXD group=0x%03x/0x%03x\n", upg_cpu, rpg_cpu);
+
+	seq_printf(s, "\tReserved page counter of HIF_TXCMD group: 0x%08x\n", pg_flow_ctrl[6]);
+	seq_printf(s, "\tHIF_TXCMD group page status: 0x%08x\n", pg_flow_ctrl[7]);
+	cpu_min_q = (pg_flow_ctrl[6] & WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MIN_QUOTA_MASK) >> WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MIN_QUOTA_SHFT;
+	cpu_max_q = (pg_flow_ctrl[6] & WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MAX_QUOTA_MASK) >> WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of HIF_TXCMD group=0x%03x/0x%03x\n", cpu_max_q, cpu_min_q);
+	rpg_cpu = (pg_flow_ctrl[7] & WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_RSV_CNT_MASK) >> WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_RSV_CNT_SHFT;
+	upg_cpu = (pg_flow_ctrl[7] & WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_SRC_CNT_MASK) >> WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of HIF_TXCMD group=0x%03x/0x%03x\n", upg_cpu, rpg_cpu);
+
+	seq_printf(s, "\tReserved page counter of CPU group(0x820c0150): 0x%08x\n", pg_flow_ctrl[4]);
+	seq_printf(s, "\tCPU group page status(0x820c0154): 0x%08x\n", pg_flow_ctrl[5]);
+	cpu_min_q = (pg_flow_ctrl[4] & WF_PLE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_MASK) >> WF_PLE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_SHFT;
+	cpu_max_q = (pg_flow_ctrl[4] & WF_PLE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_MASK) >> WF_PLE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of CPU group=0x%03x/0x%03x\n", cpu_max_q, cpu_min_q);
+	rpg_cpu = (pg_flow_ctrl[5] & WF_PLE_TOP_CPU_PG_INFO_CPU_RSV_CNT_MASK) >> WF_PLE_TOP_CPU_PG_INFO_CPU_RSV_CNT_SHFT;
+	upg_cpu = (pg_flow_ctrl[5] & WF_PLE_TOP_CPU_PG_INFO_CPU_SRC_CNT_MASK) >> WF_PLE_TOP_CPU_PG_INFO_CPU_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of CPU group=0x%03x/0x%03x\n", upg_cpu, rpg_cpu);
+
+	if ((ple_stat[0] & WF_PLE_TOP_QUEUE_EMPTY_ALL_AC_EMPTY_MASK) == 0) {
+		for (j = 0; j < ALL_CR_NUM_OF_ALL_AC; j++) {
+			if (j % CR_NUM_OF_AC == 0) {
+				seq_printf(s, "\n\tNonempty AC%d Q of STA#: ", j / CR_NUM_OF_AC);
+			}
+
+			for (i = 0; i < 32; i++) {
+				if (((ple_stat[j + 1] & (0x1 << i)) >> i) == 0) {
+					seq_printf(s, "%d ", i + (j % CR_NUM_OF_AC) * 32);
+				}
+			}
+		}
+
+		seq_printf(s, "\n");
+	}
+
+	seq_printf(s, "non-native/native txcmd queue empty = %d/%d\n", ple_txcmd_stat, ple_native_txcmd_stat);
+
+	seq_printf(s, "Nonempty Q info:\n");
+
+	for (i = 0; i < 32; i++) {
+		if (((ple_stat[0] & (0x1 << i)) >> i) == 0) {
+			u32 hfid, tfid, pktcnt, fl_que_ctrl[3] = {0};
+
+			if (ple_queue_empty_info[i].QueueName != NULL) {
+				seq_printf(s, "\t%s: ", ple_queue_empty_info[i].QueueName);
+				fl_que_ctrl[0] |= WF_PLE_TOP_FL_QUE_CTRL_0_EXECUTE_MASK;
+				fl_que_ctrl[0] |= (ple_queue_empty_info[i].Portid << WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_SHFT);
+				fl_que_ctrl[0] |= (ple_queue_empty_info[i].tgid << WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_TGID_SHFT);
+				fl_que_ctrl[0] |= (ple_queue_empty_info[i].Queueid << WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_SHFT);
+			} else
+				continue;
+
+			mt76_wr(dev, WF_PLE_TOP_FL_QUE_CTRL_0_ADDR, fl_que_ctrl[0]);
+			fl_que_ctrl[1] = mt76_rr(dev, WF_PLE_TOP_FL_QUE_CTRL_2_ADDR);
+			fl_que_ctrl[2] = mt76_rr(dev, WF_PLE_TOP_FL_QUE_CTRL_3_ADDR);
+
+			hfid = (fl_que_ctrl[1] & WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_MASK) >> WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_SHFT;
+			tfid = (fl_que_ctrl[1] & WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_MASK) >> WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_SHFT;
+			pktcnt = (fl_que_ctrl[2] & WF_PLE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_MASK) >> WF_PLE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_SHFT;
+			seq_printf(s, "tail/head fid = 0x%03x/0x%03x, pkt cnt = 0x%03x\n",
+					  tfid, hfid, pktcnt);
+
+			if (pktcnt > 0 && dumptxd > 0)
+				mt7996_dump_mac_fid(s, dev, hfid, true);
+		}
+	}
+
+	mt7996_show_sta_acq_info(s, ple_stat, sta_pause, twt_sta_pause, dumptxd);
+	mt7996_show_txcmdq_info(s, ple_native_txcmd_stat);
+
+	kfree(sta_pause);
+	kfree(twt_sta_pause);
+	return 0;
+}
+
+/* DRR */
+static int
+mt7996_drr_info(struct seq_file *s, void *data)
+{
+	/* TODO: Wait MIB counter API implement complete */
+	return 0;
+}
+
+int mt7996_mtk_init_debugfs_internal(struct mt7996_phy *phy, struct dentry *dir)
+{
+	struct mt7996_dev *dev = phy->dev;
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "drr_info", dir,
+				    mt7996_drr_info);
+
+	debugfs_create_u32("token_idx", 0600, dir, &dev->dbg.token_idx);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "token_txd", dir,
+				    mt7996_token_txd_read);
+	debugfs_create_u32("txd_dump", 0600, dir, &dev->dbg.txd_read_cnt);
+	debugfs_create_u32("rxd_dump", 0600, dir, &dev->dbg.rxd_read_cnt);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "rx_token", dir,
+				    mt7996_rx_token_read);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "rx_msdu_pg", dir,
+				    mt7996_rx_msdu_pg_read);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "ple_info", dir,
+				    mt7996_pleinfo_read);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "pse_info", dir,
+				    mt7996_pseinfo_read);
+	/* ple/pse fid raw data dump */
+	debugfs_create_u32("fid_idx", 0600, dir, &dev->dbg.fid_idx);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "ple_fid", dir,
+				    mt7996_ple_fid_read);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "pse_fid", dir,
+				    mt7996_pse_fid_read);
+	/* amsdu */
+	debugfs_create_file("amsdu_algo", 0600, dir, dev, &fops_amsdu_algo);
+	debugfs_create_file("amsdu_para", 0600, dir, dev, &fops_amsdu_para);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "amsdu_info", dir,
+	                            mt7996_amsdu_info_read);
+
+	debugfs_create_u8("dump_ple_txd", 0600, dir, &dev->dbg.dump_ple_txd);
+	return 0;
+}
+
+#endif
diff --git a/mt7996/testmode.c b/mt7996/testmode.c
index 9fa4edcd6..056c501df 100644
--- a/mt7996/testmode.c
+++ b/mt7996/testmode.c
@@ -223,6 +223,7 @@ static void
 mt7996_tm_init(struct mt7996_phy *phy, bool en)
 {
 	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)phy->monitor_vif->drv_priv;
 	u8 rf_test_mode = en ? RF_OPER_RF_TEST : RF_OPER_NORMAL;
 
 	if (!test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
@@ -234,8 +235,8 @@ mt7996_tm_init(struct mt7996_phy *phy, bool en)
 
 	mt7996_tm_rf_switch_mode(dev, rf_test_mode);
 
-	mt7996_mcu_add_bss_info(phy, phy->monitor_vif, en);
-	mt7996_mcu_add_sta(dev, phy->monitor_vif, NULL, en, false);
+	mt7996_mcu_add_bss_info(phy, &phy->monitor_vif->bss_conf, &mvif->deflink, en);
+	mt7996_mcu_add_sta(dev, &phy->monitor_vif->bss_conf, &mvif->deflink, NULL, en, false);
 
 	mt7996_tm_set(dev, SET_ID(BAND_IDX), phy->mt76->band_idx);
 
@@ -1179,13 +1180,13 @@ mt7996_tm_txbf_init(struct mt7996_phy *phy, u16 *val)
 	mt7996_tm_set_mac_addr(dev, td->addr[2], SET_ID(BSSID));
 
 	/* bss idx & omac idx should be set to band idx for ibf cal */
-	mvif->mt76.idx = band_idx;
-	dev->mt76.vif_mask |= BIT_ULL(mvif->mt76.idx);
-	mvif->mt76.omac_idx = band_idx;
-	phy->omac_mask |= BIT_ULL(mvif->mt76.omac_idx);
+	mvif->deflink.mt76.idx = band_idx;
+	dev->mt76.vif_mask |= BIT_ULL(mvif->deflink.mt76.idx);
+	mvif->deflink.mt76.omac_idx = band_idx;
+	phy->omac_mask |= BIT_ULL(mvif->deflink.mt76.omac_idx);
 
-	mt7996_mcu_add_dev_info(phy, phy->monitor_vif, true);
-	mt7996_mcu_add_bss_info(phy, phy->monitor_vif, true);
+	mt7996_mcu_add_dev_info(phy, &phy->monitor_vif->bss_conf, &mvif->deflink, true);
+	mt7996_mcu_add_bss_info(phy, &phy->monitor_vif->bss_conf, &mvif->deflink, true);
 
 	if (td->ibf) {
 		if (td->is_txbf_dut) {
-- 
2.39.2

